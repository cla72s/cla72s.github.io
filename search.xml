<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>纯真社区版IP库CZDB数据格式使用教程</title>
      <link href="/2025/02/27/%E7%BA%AF%E7%9C%9F%E7%A4%BE%E5%8C%BA%E7%89%88IP%E5%BA%93CZDB%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2025/02/27/%E7%BA%AF%E7%9C%9F%E7%A4%BE%E5%8C%BA%E7%89%88IP%E5%BA%93CZDB%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h4><p>纯真社区版IP库是免费和公开的，并非商业数据库。CZDB格式是全新数据文件格式，并计划从2024年10月开始只维护更新该格式的数据。该IP库文件同时支持IPv4和IPv6地理位置数据，具有占用内存小，访问速度快，线程安全，更新方便快捷的特点。</p><span id="more"></span><h4 id="2、下载"><a href="#2、下载" class="headerlink" title="2、下载"></a>2、下载</h4><p>第一步、在纯真官网(纯真网络，中国历史最悠久的IP地理位置库)上注册并登录。在菜单中点击离线库，选择“纯真社区版IP库”。</p><p><img src="/./../img/j1.jpg"></p><p>IP地址位置数据由<a href=" ">纯真CZ88</a >提供支持</p >]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法：Z 函数</title>
      <link href="/2024/03/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9AZ-%E5%87%BD%E6%95%B0/"/>
      <url>/2024/03/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9AZ-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>该算法一半用于计算一个字符串的最长相同前后缀，国外一般将计算该数组的算法称为 Z Algorithm，而国内则称其为 扩展 KMP。</p><span id="more"></span><p>对于一个长度为 n 的字符串 s，定义函数 z[i] 表示 s 和 s[i,n-1]（即以 s[i] 开头的后缀）的最长公共前缀（LCP）的长度，则 z 被称为 s 的 Z 函数。特别地，z[0] &#x3D; 0。</p><h2 id="线性实现代码："><a href="#线性实现代码：" class="headerlink" title="线性实现代码："></a>线性实现代码：</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="built_in">int</span><span class="literal">[]</span> z<span class="constructor">Function(String <span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">int</span><span class="literal">[]</span> z = <span class="keyword">new</span> <span class="built_in">int</span><span class="literal">[<span class="identifier">s</span>.<span class="identifier">length</span>()]</span>;</span><br><span class="line">  <span class="built_in">int</span> l = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">int</span> r = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; s.length<span class="literal">()</span>;i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt;= r)&#123;</span><br><span class="line">          z<span class="literal">[<span class="identifier">i</span>]</span> = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>min(z<span class="literal">[<span class="identifier">i</span> - <span class="identifier">l</span>]</span>, r - i + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (i + z<span class="literal">[<span class="identifier">i</span>]</span> &lt; s.length<span class="literal">()</span><span class="operator"> </span></span><br><span class="line"><span class="operator">            &amp;&amp; </span>s.<span class="built_in">char</span><span class="constructor">At(<span class="params">z</span>[<span class="params">i</span>])</span><span class="operator"> == </span>s.<span class="built_in">char</span><span class="constructor">At(<span class="params">i</span> + <span class="params">z</span>[<span class="params">i</span>])</span>) &#123;</span><br><span class="line">          l = i;</span><br><span class="line">          r = i + z<span class="literal">[<span class="identifier">i</span>]</span>;</span><br><span class="line">          z<span class="literal">[<span class="identifier">i</span>]</span>++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> z函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 CentOS 8 上安装 MySQL8.0 以及外网连接</title>
      <link href="/2023/12/09/Linux/%E5%9C%A8-CentOS-8-%E4%B8%8A%E5%AE%89%E8%A3%85-MySQL8-0/"/>
      <url>/2023/12/09/Linux/%E5%9C%A8-CentOS-8-%E4%B8%8A%E5%AE%89%E8%A3%85-MySQL8-0/</url>
      
        <content type="html"><![CDATA[<p>在 CentOS 8 上安装 MySQL 以及外网连接</p><span id="more"></span><h2 id="一、在-CentOS-8-上安装-MySQL8-0"><a href="#一、在-CentOS-8-上安装-MySQL8-0" class="headerlink" title="一、在 CentOS 8 上安装 MySQL8.0"></a>一、在 CentOS 8 上安装 MySQL8.0</h2><p>以 root 或者其他有 sudo 权限的用户身份，通过使用 CentOS 包管理器来安装 MySQL 8.0 服务器：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> dnf install <span class="variable">@mysql</span></span><br></pre></td></tr></table></figure><p>@mysql 模块会安装 MySQL 和所有依赖安装包</p><p>启动命令</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="keyword">enable</span> <span class="comment">--now mysqld</span></span><br></pre></td></tr></table></figure><p>检查是否在运行</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo systemctl status mysqld</span></span><br></pre></td></tr></table></figure><h2 id="二、保护-MySQL"><a href="#二、保护-MySQL" class="headerlink" title="二、保护 MySQL"></a>二、保护 MySQL</h2><p>运行 <code>mysql_secure_installation</code> 脚本，执行一些安全相关的操作，并且设置 MySQL root 用户密码：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo mysql_secure_installation</span></span><br></pre></td></tr></table></figure><p>为了通过终端命令行与 MySQL 数据库交互，使用已经安装的 MySQL 客户端工具。测试 root 用户访问，输入 :</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -<span class="selector-tag">p</span></span><br></pre></td></tr></table></figure><h2 id="三、用户验证"><a href="#三、用户验证" class="headerlink" title="三、用户验证"></a>三、用户验证</h2><p>CentOS 8 源仓库中的 MySQL 8.0 被设置采用古老的 <code>mysql_native_password</code> 用户验证插件，因为 CentOS 8 上的一些客户端工具和库不兼容 <code>caching_sha2_password</code> 这个 标准 MySQL 8.0 默认采用的方法。</p><p><code>mysql_native_password</code> 在大部分设置中都没问题。如果你想将默认的用户验证插件修改为更快更安全的 <code>caching_sha2_password</code> ，打开下面的配置文件：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim <span class="regexp">/etc/my</span>.cnf.d/mysql-<span class="keyword">default</span>-authentication-plugin.cnf</span><br></pre></td></tr></table></figure><p>将默认的 <code>default_authentication_plugin</code> 修改为 <code>caching_sha2_password</code> :</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">default_authentication_plugin</span>=caching_sha2_password</span><br></pre></td></tr></table></figure><p>重启 MySQL 服务器</p><pre><code>sudo systemctl restart mysqld</code></pre><h2 id="四、修改-MySQL-用户权限使用外网连接"><a href="#四、修改-MySQL-用户权限使用外网连接" class="headerlink" title="四、修改 MySQL 用户权限使用外网连接"></a>四、修改 MySQL 用户权限使用外网连接</h2><ul><li><p>查看用户权限</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line"><span class="keyword">select</span> Host,<span class="keyword">User</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">user</span>=<span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/./../../img/linux/mp1.png"><br>我这里已经开放了外网权限,没有开放 % 显示的是 localhost</p></li><li><p>修改 Host 为%,代表外网可以连接,并刷新</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> Host=<span class="string">&#x27;%&#x27;</span> <span class="keyword">where</span> <span class="keyword">User</span> =<span class="string">&#x27;root&#x27;</span>;</span><br><span class="line">FLUSH <span class="keyword">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure></li><li><p>再将 CentOS 8 的防火墙给关闭了</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 查看防火墙状态</span><br><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure><p><img src="/./../../img/linux/mp2.png"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 关闭防火墙</span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="regexp">//</span> 查看状态</span><br><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure><p><img src="/./../../img/linux/mp3.png"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 设置虚拟机启动后，防火墙的默认状态</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure></li><li><p>经过这两项操作之后就可以在自己电脑上连接 MySQL 了。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac OS 下安装 CentOS 8 虚拟机</title>
      <link href="/2023/12/09/Linux/Mac-OS-%E4%B8%8B%E5%AE%89%E8%A3%85-Cent-OS8-%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2023/12/09/Linux/Mac-OS-%E4%B8%8B%E5%AE%89%E8%A3%85-Cent-OS8-%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>前几天自己的腾讯云服务器到期了，要用到 linux 操作系统，只能自己下载一个虚拟机了。</p><p>接下来介绍下，在 mac 电脑中 如何安装一个 Cent OS 8。</p><span id="more"></span><h2 id="一、下载原料"><a href="#一、下载原料" class="headerlink" title="一、下载原料"></a>一、下载原料</h2><ul><li>安装 VMware Fusion 虚拟机软件</li><li>下载一个 Cent OS 8 的镜像资源</li><li>安装一个 Termius Beta</li></ul><p>链接: <a href="https://pan.baidu.com/s/17FDx8OJesbP5f8SIaOWIEw?pwd=yspa">https://pan.baidu.com/s/17FDx8OJesbP5f8SIaOWIEw?pwd=yspa</a> 提取码: yspa</p><p><strong>以下是官网下载地址</strong></p><ol><li>CentOS 8：</li></ol><ul><li>官网：<a href="https://www.centos.org/">下载 CentOS</a></li><li>阿里云镜像资源：<a href="https://mirrors.aliyun.com/centos/8-stream/isos/x86_64/">下载 CentOS 8 镜像</a></li></ul><ol start="2"><li>VMware Fusion：</li></ol><ul><li>官网：<a href="https://www.vmware.com/cn/products/fusion/fusion-evaluation.html">下载 VMware Fusion | VMware | CN</a></li></ul><ol start="3"><li>Termius Beta:</li></ol><ul><li>官网：<a href="https://www.macz.com/mac/2613.html?id=NzY5NTA5Jl8mMjcuMTg2LjEyNC40NQ==">下载跨平台 SSH 客户端 Termius Beta 中文</a></li></ul><h2 id="二、安装-VMware-Fusion"><a href="#二、安装-VMware-Fusion" class="headerlink" title="二、安装 VMware Fusion"></a>二、安装 VMware Fusion</h2><h3 id="1-准备好-VMware-Fusion-软件"><a href="#1-准备好-VMware-Fusion-软件" class="headerlink" title="1. 准备好 VMware Fusion 软件"></a>1. 准备好 VMware Fusion 软件</h3><p><img src="/./../../img/linux/linuxp1.png"></p><h3 id="2-开始安装-VMware-Fusion"><a href="#2-开始安装-VMware-Fusion" class="headerlink" title="2. 开始安装 VMware Fusion"></a>2. 开始安装 VMware Fusion</h3><ul><li>双击 <code>VMware-Fusion-13.5.0-22583790_universal.dmg</code></li><li>弹出下图窗口；双击 VMware Fusion 即可安装，然后会有密钥什么的，那就自己解决了。<br><img src="/./../../img/linux/linuxp2.png"></li><li>弹出窗口<br><img src="/./../../img/linux/linuxp3.png"></li></ul><h3 id="3-配置-VMware-Fusion-网络"><a href="#3-配置-VMware-Fusion-网络" class="headerlink" title="3. 配置 VMware Fusion 网络"></a>3. 配置 VMware Fusion 网络</h3><ul><li><p>打开 VMware Fusion 偏好设置<br><img src="/./../../img/linux/linuxp4.png"></p></li><li><p>弹出窗口，选中 1，点击 2 解锁；然输入密码。<br><img src="/./../../img/linux/linuxp5.png"></p></li><li><p>开锁完成后，点击 <code>+</code> 号，默认就会添加一个 vmnet2 的网络，按图中所示勾选即可，后上锁。<br><img src="/./../../img/linux/linuxp6.png"></p></li><li><p>打开终端，进入目录</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 目录：<span class="regexp">/Library/</span>Preferences/VMware Fusion</span><br><span class="line"><span class="regexp">//</span> 终端输入指令：</span><br><span class="line">cd  <span class="regexp">/Library/</span>Preferences/VMware\ Fusion</span><br><span class="line"><span class="regexp">//</span> 之后再使用 sudo vim 修改该目录下的 networking</span><br><span class="line">sudo vim networking</span><br></pre></td></tr></table></figure><p><img src="/./../../img/linux/linuxp7.png"></p></li><li><p>修改文件，并保存<br><img src="/./../../img/linux/linuxp8.png"></p></li><li><p>进入该目录下的 vmnet2 目录，修改 nat.conf 文件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> vmnet2</span><br><span class="line">sudo <span class="keyword">vim</span> nat.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure><p><img src="/./../../img/linux/linuxp9.png"><br><img src="/./../../img/linux/linuxp10.png"></p></li><li><p>保存，退出</p></li><li><p><strong>注意：有坑 上边的网关 ip 地址 192.168.77.2 第四个字节设置为 2，不要设置成其他的；因为发现，当应用网络后，第四个字节会自动的恢复成 2</strong></p></li><li><p>重新配置 vmnet2 网络(重新打开 VMware Funsion)</p></li><li><p>回到 VMware 偏好设置，重新应用下 vmnet2<br><img src="/./../../img/linux/linuxp11.png"></p></li></ul><h3 id="4-新建虚拟机"><a href="#4-新建虚拟机" class="headerlink" title="4. 新建虚拟机"></a>4. 新建虚拟机</h3><ul><li>步骤<br><img src="/./../../img/linux/linuxp12.png"><br><img src="/./../../img/linux/linuxp13.png"><br><img src="/./../../img/linux/linuxp14.png"><br><img src="/./../../img/linux/linuxp15.png"><br><img src="/./../../img/linux/linuxp16.png"><br><img src="/./../../img/linux/linuxp17.png"></li></ul><h3 id="5-设置虚拟机"><a href="#5-设置虚拟机" class="headerlink" title="5. 设置虚拟机"></a>5. 设置虚拟机</h3><ul><li>因为还没有关联镜像文件，可以先关闭虚拟机<br><img src="/./../../img/linux/linuxp18.png"><br><img src="/./../../img/linux/linuxp19.png"></li><li>设置虚拟机内存和处理器<br><img src="/./../../img/linux/linuxp20.png"><br><img src="/./../../img/linux/linuxp21.png"></li><li>设置网络适配器为 vmnet2<br><img src="/./../../img/linux/linuxp22.png"><br><img src="/./../../img/linux/linuxp23.png"></li><li>声卡和摄像头都可以移除，虚拟机应该用不到这些</li><li>连接光驱，选择镜像文件<br><img src="/./../../img/linux/linuxp28.png"><br><img src="/./../../img/linux/linuxp24.png"><br><img src="/./../../img/linux/linuxp25.png"></li><li>使用光驱来启动<br><img src="/./../../img/linux/linuxp26.png"><br><img src="/./../../img/linux/linuxp27.png"></li></ul><h3 id="6-安装-CentOS-8"><a href="#6-安装-CentOS-8" class="headerlink" title="6. 安装 CentOS 8"></a>6. 安装 CentOS 8</h3><ul><li>开始安装，用键盘方向键选中 <code>Install CentOS Stream 8</code>，然后回车，开始安装。<br><img src="/./../../img/linux/linuxp29.png"></li><li>设置语言<br><img src="/./../../img/linux/linuxp30.png"></li><li>接下来配置这四项<br><img src="/./../../img/linux/linuxp31.png"></li><li>将时区设置为上海，调整时间<br><img src="/./../../img/linux/linuxp32.png"></li><li>设置磁盘<br><img src="/./../../img/linux/linuxp33.png"></li><li>设置网络<br><img src="/./../../img/linux/linuxp34.png"><br><img src="/./../../img/linux/linuxp35.png"><br><img src="/./../../img/linux/linuxp36.png"></li><li>设置 root 用户密码<br><img src="/./../../img/linux/linuxp37.png"></li><li>开始安装，需要等待的时间还是挺久的<br><img src="/./../../img/linux/linuxp38.png"></li><li>安装完成之后重启<br><img src="/./../../img/linux/linuxp39.png"></li><li>接受协议，后面就是设置密码，就可以登录了<br><img src="/./../../img/linux/linuxp40.png"><br><img src="/./../../img/linux/linuxp41.png"><br><img src="/./../../img/linux/linuxp42.png"><br><img src="/./../../img/linux/linuxp43.png"><br><img src="/./../../img/linux/linuxp44.png"></li></ul><h2 id="三、安装-Termius-Beta"><a href="#三、安装-Termius-Beta" class="headerlink" title="三、安装 Termius Beta"></a>三、安装 Termius Beta</h2><h3 id="1-准备好-Termius-Beta-软件"><a href="#1-准备好-Termius-Beta-软件" class="headerlink" title="1. 准备好 Termius Beta 软件"></a>1. 准备好 Termius Beta 软件</h3><p><img src="/./../../img/linux/linuxp1.png"></p><h3 id="2-开始安装-Termius-Beta"><a href="#2-开始安装-Termius-Beta" class="headerlink" title="2. 开始安装 Termius Beta"></a>2. 开始安装 Termius Beta</h3><ul><li>双击上图的 <code>TermiusBeta_macll.dmg</code><br><img src="/./../../img/linux/linuxp45.png"></li><li>将 Termius Beta 拖到 Applications 中即可<br><img src="/./../../img/linux/linuxp46.png"></li><li>然后就会出现已损坏的消息，其实并不是损坏，而是 mac 对它不信任<br><img src="/./../../img/linux/linuxp47.png"><br>解决方法：<a href="https://www.macz.com/news/1.html">Termius Beta 已损坏 的解决方法</a></li></ul><h3 id="3-连接-VMware-Fusion-虚拟机"><a href="#3-连接-VMware-Fusion-虚拟机" class="headerlink" title="3. 连接 VMware Fusion 虚拟机"></a>3. 连接 VMware Fusion 虚拟机</h3><ul><li>连接刚刚虚拟机设置的 host<br><img src="/./../../img/linux/linuxp48.png"></li><li>输入三个登录信息<br><img src="/./../../img/linux/linuxp49.png"></li><li>点击继续连接<br><img src="/./../../img/linux/linuxp50.png"></li><li>这样就连接上了虚拟机，可以用 Termius Beta 进行指令操作<br><img src="/./../../img/linux/linuxp51.png"></li></ul><h3 id="4-用-Termius-Beta-进行相关设置"><a href="#4-用-Termius-Beta-进行相关设置" class="headerlink" title="4. 用 Termius Beta 进行相关设置"></a>4. 用 Termius Beta 进行相关设置</h3><ul><li>编辑配置文件<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/etc/</span>sysconfig<span class="regexp">/network-scripts/</span></span><br><span class="line">vi ifcfg-ens160</span><br><span class="line"><span class="regexp">//</span> 或者</span><br><span class="line">vi <span class="regexp">/etc/</span>sysconfig<span class="regexp">/network-scripts/i</span>fcfg-ens160</span><br></pre></td></tr></table></figure><img src="/./../../img/linux/linuxp52.png"></li><li>更改完网络配置，重启网络服务<br><img src="/./../../img/linux/linuxp53.png"><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmcli <span class="keyword">c</span> reload</span><br><span class="line">nmcli <span class="keyword">c</span> up ens<span class="number">160</span></span><br></pre></td></tr></table></figure></li><li>安装一些常用软件<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y <span class="keyword">install</span> vim</span><br><span class="line">yum -y <span class="keyword">install</span> net-tools</span><br></pre></td></tr></table></figure><img src="/./../../img/linux/linuxp54.png"></li><li>关机<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init <span class="number">0</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>设置虚拟机从硬盘方式启动<br><img src="/./../../img/linux/linuxp55.png"></li></ul><h2 id="四、克隆-Linux-虚拟机"><a href="#四、克隆-Linux-虚拟机" class="headerlink" title="四、克隆 Linux 虚拟机"></a>四、克隆 Linux 虚拟机</h2><ul><li>将需要克隆的虚拟机关机，之后可以克隆虚拟机<br><img src="/./../../img/linux/linuxp56.png"></li><li>另起名 002，克隆出来的虚拟机是一模一样的，IP 地址也一样，所以还需要将其 IP 地址更改，启动新克隆的虚拟机<br><img src="/./../../img/linux/linuxp57.png"></li><li>使用 Termius Beta 登录，修改其 IP 地址<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi <span class="regexp">/etc/</span>sysconfig<span class="regexp">/network-scripts/i</span>fcfg-ens160</span><br></pre></td></tr></table></figure><img src="/./../../img/linux/linuxp59.png"></li><li>修改 IP 地址为 110<br><img src="/./../../img/linux/linuxp58.png"></li><li>重启网络服务<br><img src="/./../../img/linux/linuxp60.png"></li><li>建立新的服务器连接，将原先的 192.168.77.100 改为 192.168.77.110<br><img src="/./../../img/linux/lp61.png"></li><li>即可打开新克隆的 Linux 虚拟机<br><img src="/./../../img/linux/lp62.png"></li></ul><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li>到这里，所有的虚拟机配置都讲述完了，如果还需要搭建其他的集群什么的，操作都差不多。</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：KMP</title>
      <link href="/2023/09/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9AKMP/"/>
      <url>/2023/09/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9AKMP/</url>
      
        <content type="html"><![CDATA[<p>KMP 是用于字符串匹配的算法，其将字符串匹配复杂度降至 O(n)级别。</p><span id="more"></span><p>目标字符串 s, 需匹配的字符串 t</p><p>当遍历至 字符不匹配时 查询 当前 s 串的后缀串 与 t 的前缀串 匹配的最长的那一个。</p><p>为了快速寻找到匹配上的最长前缀串，借用数组 next ， 其保存了若不匹配后 最长后缀串 的长度。</p><h3 id="生成-next-数组："><a href="#生成-next-数组：" class="headerlink" title="生成 next 数组："></a>生成 next 数组：</h3><pre><code>vector&lt;int&gt; kmpGetNext(const string&amp; str)&#123;    int n = (int)str.size(), k = 0;    vector&lt;int&gt; next(n);    next[0] = 0;    for(int i = 1; i &lt; n ; ++i)&#123;        while(k &gt; 0 &amp;&amp; str[i]!=str[k]) k = next[k-1];        if(str[i] == str[k]) ++k;        next[i] = k;    &#125;    return next;&#125;</code></pre><h3 id="查询-s-中是否有-t-串："><a href="#查询-s-中是否有-t-串：" class="headerlink" title="查询 s 中是否有 t 串："></a>查询 s 中是否有 t 串：</h3><pre><code>bool kmp(string&amp; str1, string&amp; str2)&#123;    int n = (int)str1.size(), m = (int)str2.size(), k = 0;    vector&lt;int&gt; nextArr = kmpGetNext(str2);    for(int i = 0;i &lt; n;++i)&#123;        while (k &gt; 0 &amp;&amp; str1[i] != str2[k]) &#123;            k = nextArr[k-1];        &#125;        if (str1[i] == str2[k]) &#123;            ++k;        &#125;        if (k == m) return true;    &#125;    return false;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kmp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：差分数组</title>
      <link href="/2023/09/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
      <url>/2023/09/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>利用差分数组使区间操作更加简单，区间操作的时间复杂度可以变为<code>O(1)</code>;</p><span id="more"></span><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><p>原生态数组：<code>a[8, 4, 6, 7, 9, 3, 1, 5]</code> 。</p><p>对其中的相邻元素两两作差（右边减左边），得到的数组然后在开头补上 <code>a[0]</code> 。</p><p>最终结果为：<code>b[8, -4, 2, 1, 2, -6, -2, 4]</code> 。</p><p>这有什么用呢？如果从左到右累加 b 中的元素，我们就「还原」回了 a 数组 。</p><p>这又有什么用呢？现在把 a 数组的(1~4)子数组 全加上一个数 10 。</p><p>a 数组变为 ：<code>[8, 14, 16, 17, 19, 3, 1, 5]</code> 。</p><p>它的差分数组则变为：<code>[8, 6, 2, 1, 2, -16, -2, 4]</code> 。</p><p>对比差分数组的变化，可以发现 对连续区间 (1~4) 的子数组 进行操作 最终差分数组只有 b[1] 和 b[5] 发生变化。</p><p>这种变化，可以将一个<strong>多数</strong>操作变为<strong>两个数</strong>的操作。</p><h3 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h3><p>性质 1. 从左到右累加 差分数组 中的元素，可以得到原数组 。<br>性质 2. 将以下两个操作变为等价 ：</p><ul><li>区间操作：将 a 的子数组 a[i], a[i+1], …, a[j] 全加上 x 。</li><li>单点操作：将 b 的 b[i] 加上 x , b[j+1] 减去 x 。(特别地 j+1 &#x3D; n, 则不需要 b[j+1] 减去 x)。</li></ul><p>常常性质二可以加快算法题的时间复杂度。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 差分数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长上升子序列</title>
      <link href="/2023/03/31/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2023/03/31/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><span id="more"></span><p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：</p><pre><code>输入：nums = [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</code></pre><p>示例 2：</p><pre><code>输入：nums = [0,1,0,3,2,3]输出：4</code></pre><p>示例 3：</p><pre><code>输入：nums = [7,7,7,7,7,7,7]输出：1</code></pre><p> </p><p>提示：</p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 2500</li><li>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</li></ul><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">题目原题</a></p><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution &#123;public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;        int n=(int)nums.size();        if (n == 0) return 0;        vector&lt;int&gt; dp(n, 1);        for (int i = 0; i &lt; n; ++i) &#123;            for (int j = 0; j &lt; i; ++j) &#123;                if (nums[j] &lt; nums[i]) &#123;                    dp[i] = max(dp[i], dp[j] + 1);                &#125;            &#125;        &#125;        return *max_element(dp.begin(), dp.end());    &#125;&#125;;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(n ^ 2)</code>。</li><li>空间复杂度：<code>O(n)</code>。</li></ul><h2 id="方法二：贪心-二分查找"><a href="#方法二：贪心-二分查找" class="headerlink" title="方法二：贪心+二分查找"></a>方法二：贪心+二分查找</h2><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution &#123;public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;        int n = nums.size(),len = 1;        vector&lt;int&gt; dp(n + 1);        dp[1] = nums[0];        for (int i = 1;i &lt; n;++i)&#123;            if (nums[i] &gt; dp[len]) dp[++len] = nums[i];            else &#123;                *lower_bound(dp.begin()+1,dp.begin()+len+1,nums[i]) = nums[i];            &#125;        &#125;        return len;    &#125;&#125;;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(n log n)</code>。</li><li>空间复杂度：<code>O(n)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计美丽子数组数目</title>
      <link href="/2023/03/29/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%BB%9F%E8%AE%A1%E7%BE%8E%E4%B8%BD%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/"/>
      <url>/2023/03/29/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%BB%9F%E8%AE%A1%E7%BE%8E%E4%B8%BD%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>给你一个下标从 <code>0</code> 开始的整数数组 <code>nums</code> 。每次操作中，你可以：</p><span id="more"></span><ul><li>选择两个满足 <code>0 &lt;= i, j &lt; nums.length</code> 的不同下标 <code>i</code> 和 <code>j</code> 。</li><li>选择一个非负整数 <code>k</code> ，满足 <code>nums[i]</code> 和 <code>nums[j]</code> 在二进制下的第 <code>k</code> 位（下标编号从 <code>0</code> 开始）是 <code>1</code> 。</li><li>将 <code>nums[i]</code> 和 <code>nums[j]</code> 都减去 2<sup>k</sup> 。</li></ul><p>如果一个子数组内执行上述操作若干次后，该子数组可以变成一个全为 0 的数组，那么我们称它是一个 美丽 的子数组。</p><p>请你返回数组 <code>nums</code> 中 美丽子数组 的数目。</p><p>子数组是一个数组中一段连续 非空 的元素序列。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [4,3,1,2,4]输出：2解释：nums 中有 2 个美丽子数组：[4,3,1,2,4] 和 [4,3,1,2,4] 。- 按照下述步骤，我们可以将子数组 [3,1,2] 中所有元素变成 0 ：- 选择 [3, 1, 2] 和 k = 1 。将 2 个数字都减去 21 ，子数组变成 [1, 1, 0] 。- 选择 [1, 1, 0] 和 k = 0 。将 2 个数字都减去 20 ，子数组变成 [0, 0, 0] 。- 按照下述步骤，我们可以将子数组 [4,3,1,2,4] 中所有元素变成 0 ：- 选择 [4, 3, 1, 2, 4] 和 k = 2 。将 2 个数字都减去 22 ，子数组变成 [0, 3, 1, 2, 0] 。- 选择 [0, 3, 1, 2, 0] 和 k = 0 。将 2 个数字都减去 20 ，子数组变成 [0, 2, 0, 2, 0] 。- 选择 [0, 2, 0, 2, 0] 和 k = 1 。将 2 个数字都减去 21 ，子数组变成 [0, 0, 0, 0, 0] 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1,10,4]输出：0解释：nums 中没有任何美丽子数组。</code></pre><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 105</li><li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 106</li></ul><p><a href="https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/description/">原题出处</a></p><h2 id="方法一：前缀和-位运算"><a href="#方法一：前缀和-位运算" class="headerlink" title="方法一：前缀和 + 位运算"></a>方法一：前缀和 + 位运算</h2><pre><code>class Solution &#123;public:    long long beautifulSubarrays(vector&lt;int&gt;&amp; nums) &#123;        int n = nums.size();        long long ans = 0;        // 前缀和数组        vector&lt;int&gt; sum(n + 1);        partial_sum(nums.begin(),nums.end(),sum.begin() + 1,[&amp;](int x,int y)&#123;return x ^ y;&#125;);        unordered_map&lt;int, int&gt; cnt;        for (int &amp; x : sum) ans += cnt[x]++;        return ans;    &#125;&#125;;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(n)</code>。</li><li>空间复杂度：<code>O(n)</code>。</li></ul><p>优化：</p><pre><code>class Solution &#123;public:    long long beautifulSubarrays(vector&lt;int&gt; &amp;nums) &#123;        long long ans = 0;        int s = 0;        unordered_map&lt;int, int&gt; cnt&#123;&#123;0, 1&#125;&#125;;        for (int x : nums) &#123;            s ^= x;            ans += cnt[s]++;        &#125;        return ans;    &#125;&#125;;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(n)</code>。</li><li>空间复杂度：<code>O(n)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短公共超序列</title>
      <link href="/2023/03/28/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%9C%80%E7%9F%AD%E5%85%AC%E5%85%B1%E8%B6%85%E5%BA%8F%E5%88%97/"/>
      <url>/2023/03/28/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%9C%80%E7%9F%AD%E5%85%AC%E5%85%B1%E8%B6%85%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>给出两个字符串 <code>str1</code> 和 <code>str2</code>，返回同时以 <code>str1</code> 和 <code>str2</code> 作为子序列的最短字符串。如果答案不止一个，则可以返回满足条件的任意一个答案。</p><span id="more"></span><p>（如果从字符串 <code>T</code> 中删除一些字符（也可能不删除，并且选出的这些字符可以位于 <code>T</code> 中的 任意位置），可以得到字符串 <code>S</code>，那么 <code>S</code> 就是 <code>T</code> 的子序列）</p><p><strong>示例：</strong></p><pre><code>输入：str1 = &quot;abac&quot;, str2 = &quot;cab&quot;输出：&quot;cabac&quot;解释：str1 = &quot;abac&quot; 是 &quot;cabac&quot; 的一个子串，因为我们可以删去 &quot;cabac&quot; 的第一个 &quot;c&quot;得到 &quot;abac&quot;。 str2 = &quot;cab&quot; 是 &quot;cabac&quot; 的一个子串，因为我们可以删去 &quot;cabac&quot; 末尾的 &quot;ac&quot; 得到 &quot;cab&quot;。最终我们给出的答案是满足上述属性的最短字符串。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= str1.length, str2.length &lt;= 1000</code></li><li><code>str1 和 str2 都由小写英文字母组成。</code></li></ul><p><a href="https://leetcode.cn/problems/shortest-common-supersequence/description/">原题处</a></p><h2 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h2><pre><code>class Solution &#123;public:    string shortestCommonSupersequence(string &amp;s, string &amp;t) &#123;        int n = s.length(), m = t.length(), f[n + 1][m + 1];        for (int j = 0; j &lt; m; ++j) f[0][j] = j;        for (int i = 1; i &lt; n; ++i) f[i][0] = i;        for (int i = 0; i &lt; n; ++i)            for (int j = 0; j &lt; m; ++j)                if (s[i] == t[j])                     f[i + 1][j + 1] = f[i][j] + 1;                else                     f[i + 1][j + 1] = min(f[i][j + 1], f[i + 1][j]) + 1;        string ans;        int i = n - 1, j = m - 1;        while (~i &amp;&amp; ~j) &#123;            if (s[i] == t[j]) &#123;                 ans += s[i];                --i;                --j;             &#125; else if (f[i + 1][j + 1] == f[i][j + 1] + 1)                ans += s[i--];             else                ans += t[j--];         &#125;        reverse(ans.begin(), ans.end());                return s.substr(0, i + 1) + t.substr(0, j + 1) + ans;    &#125;&#125;;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(m * n)</code>。</li><li>空间复杂度：<code>O(m * n)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修车的最少时间</title>
      <link href="/2023/03/27/%E7%AE%97%E6%B3%95%E9%A2%98/%E4%BF%AE%E8%BD%A6%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/"/>
      <url>/2023/03/27/%E7%AE%97%E6%B3%95%E9%A2%98/%E4%BF%AE%E8%BD%A6%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>给你一个整数数组 <code>ranks</code> ，表示一些机械工的 能力值 。<code>ranks[i]</code> 是第 <code>i</code> 位机械工的能力值。能力值为 <code>r</code> 的机械工可以在 <code>r * n2</code> 分钟内修好 <code>n</code> 辆车。</p><span id="more"></span><p>同时给你一个整数 <code>cars</code> ，表示总共需要修理的汽车数目。</p><p>请你返回修理所有汽车 最少 需要多少时间。</p><p>注意：所有机械工可以同时修理汽车。</p><p><strong>示例 1：</strong></p><pre><code>输入：ranks = [4,2,3,1], cars = 10输出：16解释：- 第一位机械工修 2 辆车，需要 4 * 2 * 2 = 16 分钟。- 第二位机械工修 2 辆车，需要 2 * 2 * 2 = 8 分钟。- 第三位机械工修 2 辆车，需要 3 * 2 * 2 = 12 分钟。- 第四位机械工修 4 辆车，需要 1 * 4 * 4 = 16 分钟。16 分钟是修理完所有车需要的最少时间。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：ranks = [5,1,8], cars = 6输出：16解释：- 第一位机械工修 1 辆车，需要 5 * 1 * 1 = 5 分钟。- 第二位机械工修 4 辆车，需要 1 * 4 * 4 = 16 分钟。- 第三位机械工修 1 辆车，需要 8 * 1 * 1 = 8 分钟。16 分钟时修理完所有车需要的最少时间。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= ranks.length &lt;= 105</code></li><li><code>1 &lt;= ranks[i] &lt;= 100</code></li><li><code>1 &lt;= cars &lt;= 106</code></li></ul><p><a href="https://leetcode.cn/problems/minimum-time-to-repair-cars/description/">原题出处</a></p><h2 id="题解一："><a href="#题解一：" class="headerlink" title="题解一："></a>题解一：</h2><p>对修车时间进行二分，查找 满足题意的最小时间。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution &#123;public:    long long repairCars(vector&lt;int&gt; &amp;ranks, int cars) &#123;        int min_r = ranks[0], cnt[101]&#123;&#125;;        for (int r : ranks) &#123;            min_r = min(min_r, r);            ++cnt[r];        &#125;        long long left = 0, right = 1LL * min_r * cars * cars;        while (left + 1 &lt; right) &#123;             long long mid = (left + right) / 2, s = 0;            for (int r = min_r; r &lt;= 100; ++r)                s += (long long) sqrt(mid / r) * cnt[r];            (s &gt;= cars ? right : left) = mid;        &#125;        return right;    &#125;&#125;;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(n + M log (m * cars ^ 2))</code>。 M &#x3D; max(ranks) , m &#x3D; min(ranks)。</li><li>空间复杂度：<code>O(M)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标记所有元素后数组的分数</title>
      <link href="/2023/03/27/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%A0%87%E8%AE%B0%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E5%90%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%86%E6%95%B0/"/>
      <url>/2023/03/27/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%A0%87%E8%AE%B0%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E5%90%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%86%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给你一个数组 <code>nums</code> ，它包含若干正整数。</p><p>一开始分数 <code>score = 0</code> ，请你按照下面算法求出最后分数：</p><span id="more"></span><ul><li>从数组中选择最小且没有被标记的整数。如果有相等元素，选择下标最小的一个。</li><li>将选中的整数加到 <code>score</code> 中。</li><li>标记 被选中元素，如果有相邻元素，则同时标记 与它相邻的两个元素 。</li><li>重复此过程直到数组中所有元素都被标记。</li></ul><p>请你返回执行上述算法后最后的分数。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [2,1,3,4,5,2]输出：7解释：我们按照如下步骤标记元素：- 1 是最小未标记元素，所以标记它和相邻两个元素：[2,1,3,4,5,2] 。- 2 是最小未标记元素，所以标记它和左边相邻元素：[2,1,3,4,5,2] 。- 4 是仅剩唯一未标记的元素，所以我们标记它：[2,1,3,4,5,2] 。总得分为 1 + 2 + 4 = 7 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [2,3,5,1,3,2]输出：5解释：我们按照如下步骤标记元素：- 1 是最小未标记元素，所以标记它和相邻两个元素：[2,3,5,1,3,2] 。- 2 是最小未标记元素，由于有两个 2 ，我们选择最左边的一个 2 ，也就是下标为 0 处的 2 ，以及它右边相邻的元素：[2,3,5,1,3,2] 。- 2 是仅剩唯一未标记的元素，所以我们标记它：[2,3,5,1,3,2] 。总得分为 1 + 2 + 2 = 5 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 106</code></li></ul><p><a href="https://leetcode.cn/problems/find-score-of-an-array-after-marking-all-elements/description/">点击此去往原题处</a></p><h2 id="解题一：下标排序"><a href="#解题一：下标排序" class="headerlink" title="解题一：下标排序"></a>解题一：下标排序</h2><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution &#123;public:    long long findScore(vector&lt;int&gt; &amp;nums) &#123;        int n = nums.size(), ids[n];        iota(ids, ids + n, 0);        stable_sort(ids, ids + n, [&amp;](int i, int j) &#123;            return nums[i] &lt; nums[j];        &#125;);        long long ans = 0;        vector&lt;bool&gt; vis(n+2);         for (int i : ids)            if (!vis[i + 1]) &#123;  // 下标向右偏移一位                vis[i] = vis[i + 2] = true;                ans += nums[i];            &#125;        return ans;    &#125;&#125;;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(n * log n)</code>。</li><li>空间复杂度：<code>O(n)</code>。</li></ul><h2 id="解题二：分组循环"><a href="#解题二：分组循环" class="headerlink" title="解题二：分组循环"></a>解题二：分组循环</h2><p>可以将数组 分成 尽可能少的递减子数组，那么每个子数组的最后一位一定能被选中（因为前面一位和后面一位一定比它大，所以不可能由选中其他位置从而标记峰底元素）。所以在这个子数组中将会从后往前被标记，每隔一个元素，另一个元素将会被选中。故代码如下：</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution &#123;public:    long long findScore(vector&lt;int&gt; &amp;nums) &#123;        long long ans = 0;        for (int i = 0, n = nums.size(); i &lt; n; i += 2) &#123;            int i0 = i;            while (i + 1 &lt; n &amp;&amp; nums[i] &gt; nums[i + 1]) ++i;             // i0到i为一个递减子数组。            for (int j = i; j &gt;= i0; j -= 2) ans += nums[j];        &#125;        return ans;    &#125;&#125;;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(n)</code>。</li><li>空间复杂度：<code>O(1)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>收集树中金币</title>
      <link href="/2023/03/26/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%94%B6%E9%9B%86%E6%A0%91%E4%B8%AD%E9%87%91%E5%B8%81/"/>
      <url>/2023/03/26/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%94%B6%E9%9B%86%E6%A0%91%E4%B8%AD%E9%87%91%E5%B8%81/</url>
      
        <content type="html"><![CDATA[<p>给你一个 <code>n</code> 个节点的无向无根树，节点编号从 <code>0</code> 到 <code>n - 1</code> 。给你整数 <code>n</code> 和一个长度为 <code>n - 1</code> 的二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示树中节点 <code>ai</code> 和 <code>bi</code> 之间有一条边。再给你一个长度为 <code>n</code> 的数组 <code>coins</code> ，其中 <code>coins[i]</code> 可能为 <code>0</code> 也可能为 <code>1</code> ，<code>1</code> 表示节点 <code>i</code> 处有一个金币。</p><span id="more"></span><p>一开始，你需要选择树中任意一个节点出发。你可以执行下述操作任意次：</p><p>收集距离当前节点距离为 <code>2</code> 以内的所有金币，或者<br>移动到树中一个相邻节点。<br>你需要收集树中所有的金币，并且回到出发节点，请你返回最少经过的边数。</p><p>如果你多次经过一条边，每一次经过都会给答案加一。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2023/03/01/graph-2.png"></p><pre><code>输入：coins = [1,0,0,0,0,1], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]输出：2解释：从节点 2 出发，收集节点 0 处的金币，移动到节点 3 ，收集节点 5 处的金币，然后移动回节点 2 。</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2023/03/02/graph-4.png"></p><pre><code>输入：coins = [0,0,0,1,1,0,0,1], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]]输出：2解释：从节点 0 出发，收集节点 4 和 3 处的金币，移动到节点 2 处，收集节点 7 处的金币，移动回节点 0 。</code></pre><p><strong>提示：</strong></p><ul><li><code>n == coins.length</code></li><li><code>1 &lt;= n &lt;= 3 * 104</code></li><li><code>0 &lt;= coins[i] &lt;= 1</code></li><li><code>edges.length == n - 1</code></li><li><code>edges[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; n</code></li><li><code>ai != bi</code></li><li><code>edges</code> 表示一棵合法的树。</li></ul><p><a href="https://leetcode.cn/problems/collect-coins-in-a-tree/description/">点击此去往原题处</a></p><h2 id="解题一：拓扑排序"><a href="#解题一：拓扑排序" class="headerlink" title="解题一：拓扑排序"></a>解题一：拓扑排序</h2><pre><code>class Solution &#123;public:    int collectTheCoins(vector&lt;int&gt; &amp;coins, vector&lt;vector&lt;int&gt;&gt; &amp;edges) &#123;        int n = coins.size();        vector&lt;vector&lt;int&gt;&gt; g(n);        int deg[n]; memset(deg, 0, sizeof(deg));        for (auto &amp;e: edges) &#123;            int x = e[0], y = e[1];            g[x].push_back(y);            g[y].push_back(x); // 建图            ++deg[x];            ++deg[y];        &#125;        // 用拓扑排序「剪枝」：去掉没有金币的子树        queue&lt;int&gt; q;        for (int i = 0; i &lt; n; ++i)            if (deg[i] == 1 &amp;&amp; coins[i] == 0) // 无金币叶子                q.push(i);        while (!q.empty()) &#123;            int x = q.front();            q.pop();            for (int y: g[x])                if (--deg[y] == 1 &amp;&amp; coins[y] == 0)                    q.push(y);        &#125;        // 再次拓扑排序        for (int i = 0; i &lt; n; ++i)            if (deg[i] == 1 &amp;&amp; coins[i]) // 有金币叶子                q.push(i);        if (q.size() &lt;= 1) return 0; // 至多一个有金币的叶子，直接收集        int time[n]; memset(time, 0, sizeof(time));        while (!q.empty()) &#123;            int x = q.front();            q.pop();            for (int y: g[x])                if (--deg[y] == 1) &#123;                    time[y] = time[x] + 1; // 记录入队时间                    q.push(y);                &#125;        &#125;        // 统计答案        int ans = 0;        for (auto &amp;e: edges)            if (time[e[0]] &gt;= 2 &amp;&amp; time[e[1]] &gt;= 2)                ans += 2;        return ans;    &#125;&#125;;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(n)</code>。 </li><li>空间复杂度：<code>O(n)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使数组元素全部相等的最少操作次数</title>
      <link href="/2023/03/26/%E7%AE%97%E6%B3%95%E9%A2%98/%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%85%A8%E9%83%A8%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/"/>
      <url>/2023/03/26/%E7%AE%97%E6%B3%95%E9%A2%98/%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%85%A8%E9%83%A8%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给你一个正整数数组 <code>nums</code> 。</p><p>同时给你一个长度为 <code>m</code> 的整数数组 <code>queries</code> 。第 <code>i</code> 个查询中，你需要将 <code>nums</code> 中所有元素变成 <code>queries[i]</code> 。</p><span id="more"></span><p>你可以执行以下操作 任意 次：</p><ul><li>将数组里一个元素 增大 或者 减小 <code>1</code> 。</li></ul><p>请你返回一个长度为 <code>m</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是将 <code>nums</code> 中所有元素变成 <code>queries[i]</code> 的 最少 操作次数。</p><p>注意，每次查询后，数组变回最开始的值。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [3,1,6,8], queries = [1,5]输出：[14,10]解释：第一个查询，我们可以执行以下操作：- 将 nums[0] 减小 2 次，nums = [1,1,6,8] 。- 将 nums[2] 减小 5 次，nums = [1,1,1,8] 。- 将 nums[3] 减小 7 次，nums = [1,1,1,1] 。第一个查询的总操作次数为 2 + 5 + 7 = 14 。第二个查询，我们可以执行以下操作：- 将 nums[0] 增大 2 次，nums = [5,1,6,8] 。- 将 nums[1] 增大 4 次，nums = [5,5,6,8] 。- 将 nums[2] 减小 1 次，nums = [5,5,5,8] 。- 将 nums[3] 减小 3 次，nums = [5,5,5,5] 。第二个查询的总操作次数为 2 + 4 + 1 + 3 = 10 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [2,9,6,3], queries = [10]输出：[20]解释：我们可以将数组中所有元素都增大到 10 ，总操作次数为 8 + 1 + 4 + 7 = 20 。</code></pre><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>m == queries.length</code></li><li><code>1 &lt;= n, m &lt;= 105</code></li><li><code>1 &lt;= nums[i], queries[i] &lt;= 109</code></li></ul><p><a href="https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/">点击此去往原题处</a></p><h2 id="思路一：排序-二分查找-前缀和"><a href="#思路一：排序-二分查找-前缀和" class="headerlink" title="思路一：排序 + 二分查找 + 前缀和"></a>思路一：排序 + 二分查找 + 前缀和</h2><p>先将数组 nums 进行排序，排序后将其前缀和存入数组中，最后对每一个 queries[i] 进行二分查找计算。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution &#123;public:    vector&lt;long long&gt; minOperations(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; queries) &#123;        int n = queries.size(),m = nums.size();        vector&lt;long long&gt; ans(n),sum(m + 1);        sort(nums.begin(),nums.end());        for (int i = 1;i &lt;= m;++i) sum[i] = sum[i-1] + nums[i-1]; // 计算前缀和        for (int i = 0;i &lt; n;++i)&#123;            int index = lower_bound(nums.begin(),nums.end(),queries[i]) - nums.begin(); // 二分查找            ans[i] = sum[m] - 2*sum[index] + (long long)queries[i] * (2*index - m);        &#125;        return ans;    &#125;&#125;;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O((m + n) * logm)</code>。m 为 nums 长度，n为 queries 长度</li><li>空间复杂度：<code>O(n + m)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子集</title>
      <link href="/2023/03/25/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%AD%90%E9%9B%86/"/>
      <url>/2023/03/25/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%AD%90%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,3]输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0]输出：[[],[0]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素 互不相同</li></ul><p><a href="https://leetcode.cn/problems/subsets/description/">点击此去往原题处</a></p><h2 id="解题一：位图-位运算"><a href="#解题一：位图-位运算" class="headerlink" title="解题一：位图 + 位运算"></a>解题一：位图 + 位运算</h2><p>已知一个集合有 n 个元素，那么它的子集就有 2^n 个，那么将答案中的下标 i 看成一个位图，将 i 看成一个二进制数，它的第 j 位就代表其原集合的第 j 个元素的有无（1代表有，0代表没有）。</p><p>例如：i &#x3D; 4 则可以看出 0000000100 代表该子集有原集合第三个元素在，其余不在。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;        int n = nums.size(), ansSize = 1 &lt;&lt; n;        vector&lt;vector&lt;int&gt;&gt; ans(ansSize);        for (int i = 0;i &lt; ansSize;++i)&#123;            for (int j = 0;j &lt; n;++j)&#123;                if (i &amp; (1 &lt;&lt; j)) ans[i].push_back(nums[j]);            &#125;        &#125;                return ans;    &#125;&#125;;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(n * 2 ^ n)</code>。 遍历数组加入每一个元素。</li><li>空间复杂度：<code>O(n * 2 ^ n)</code>。 答案的开销。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符流</title>
      <link href="/2023/03/25/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%AD%97%E7%AC%A6%E6%B5%81/"/>
      <url>/2023/03/25/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%AD%97%E7%AC%A6%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>设计一个算法：接收一个字符流，并检查这些字符的后缀是否是字符串数组 <code>words</code> 中的一个字符串。</p><span id="more"></span><p>例如，<code>words = [&quot;abc&quot;, &quot;xyz&quot;]</code> 且字符流中逐个依次加入 <code>4</code> 个字符 <code>&#39;a&#39;</code>、<code>&#39;x&#39;</code>、<code>&#39;y&#39;</code> 和 <code>&#39;z&#39;</code> ，你所设计的算法应当可以检测到 <code>&quot;axyz&quot;</code> 的后缀 <code>&quot;xyz&quot;</code> 与 <code>words</code> 中的字符串 <code>&quot;xyz&quot;</code> 匹配。</p><p>按下述要求实现 <code>StreamChecker</code> 类：</p><ul><li><code>StreamChecker(String[] words)</code> ：构造函数，用字符串数组 <code>words</code> 初始化数据结构。</li><li><code>boolean query(char letter)</code>：从字符流中接收一个新字符，如果字符流中的任一非空后缀能匹配 <code>words</code> 中的某一字符串，返回 <code>true</code> ；否则，返回 <code>false</code>。</li></ul><p><strong>示例：</strong></p><pre><code>输入：[&quot;StreamChecker&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;][[[&quot;cd&quot;, &quot;f&quot;, &quot;kl&quot;]], [&quot;a&quot;], [&quot;b&quot;], [&quot;c&quot;], [&quot;d&quot;], [&quot;e&quot;], [&quot;f&quot;], [&quot;g&quot;], [&quot;h&quot;], [&quot;i&quot;], [&quot;j&quot;], [&quot;k&quot;], [&quot;l&quot;]]输出：[null, false, false, false, true, false, true, false, false, false, false, false, true]解释：StreamChecker streamChecker = new StreamChecker([&quot;cd&quot;, &quot;f&quot;, &quot;kl&quot;]);streamChecker.query(&quot;a&quot;); // 返回 FalsestreamChecker.query(&quot;b&quot;); // 返回 FalsestreamChecker.query(&quot;c&quot;); // 返回n FalsestreamChecker.query(&quot;d&quot;); // 返回 True ，因为 &#39;cd&#39; 在 words 中streamChecker.query(&quot;e&quot;); // 返回 FalsestreamChecker.query(&quot;f&quot;); // 返回 True ，因为 &#39;f&#39; 在 words 中streamChecker.query(&quot;g&quot;); // 返回 FalsestreamChecker.query(&quot;h&quot;); // 返回 FalsestreamChecker.query(&quot;i&quot;); // 返回 FalsestreamChecker.query(&quot;j&quot;); // 返回 FalsestreamChecker.query(&quot;k&quot;); // 返回 FalsestreamChecker.query(&quot;l&quot;); // 返回 True ，因为 &#39;kl&#39; 在 words 中</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= words.length &lt;= 2000</code></li><li><code>1 &lt;= words[i].length &lt;= 200</code></li><li><code>words[i]</code> 由小写英文字母组成</li><li><code>letter</code> 是一个小写英文字母</li><li>最多调用查询 <code>4 * 104</code> 次</li></ul><p><a href="https://leetcode.cn/problems/stream-of-characters/">点击此去往原题处</a></p><h2 id="解题一：字典树"><a href="#解题一：字典树" class="headerlink" title="解题一：字典树"></a>解题一：字典树</h2><pre><code>class Trie &#123;public:    vector&lt;Trie*&gt; children;    bool isEnd;    Trie()        : children(26)        , isEnd(false) &#123;&#125;    void insert(string &amp; w)&#123;        Trie *trie = this;        reverse(w.begin(),w.end());        for (char &amp; c : w)&#123;            int index = c - &#39;a&#39;;            if (!trie -&gt; children[index])                trie -&gt; children[index] = new Trie();            trie = trie -&gt; children[index];        &#125;        trie -&gt; isEnd = true;    &#125;    bool search(string &amp;w)&#123; //这里一定得用引用，不然时间会超时        Trie *trie = this;        for (int i = w.size() - 1,j = 0;~i &amp;&amp; j &lt; 201;--i,++j)&#123;            int index = w[i] - &#39;a&#39;;            if (trie -&gt; children[index] == NULL)&#123;                return false;            &#125;            trie = trie -&gt; children[index];            if (trie -&gt; isEnd) return true;        &#125;        return false;    &#125;&#125;;class StreamChecker &#123;public:    Trie* trie = new Trie();    string s;    StreamChecker(vector&lt;string&gt;&amp; words) &#123;        for(string word : words)&#123;            trie -&gt; insert(word);        &#125;    &#125;    bool query(char letter) &#123;        s += letter;        return trie -&gt; search(s);    &#125;&#125;;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(L) + O(M)</code>， 其中 <code>L</code> 为 <code>words</code> 的长度 <code>M</code> 为 <code>words</code> 中最大 <code>word</code> 的长度。</li><li>空间复杂度：<code>O(L)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>检查骑士巡视方案</title>
      <link href="/2023/03/21/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%A3%80%E6%9F%A5%E9%AA%91%E5%A3%AB%E5%B7%A1%E8%A7%86%E6%96%B9%E6%A1%88/"/>
      <url>/2023/03/21/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%A3%80%E6%9F%A5%E9%AA%91%E5%A3%AB%E5%B7%A1%E8%A7%86%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>骑士在一张 <code>n x n</code> 的棋盘上巡视。在有效的巡视方案中，骑士会从棋盘的 左上角 出发，并且访问棋盘上的每个格子 恰好一次 。</p><p>给你一个 <code>n x n</code> 的整数矩阵 grid ，由范围 <code>[0, n * n - 1]</code> 内的不同整数组成，其中 <code>grid[row][col]</code> 表示单元格 <code>(row, col)</code> 是骑士访问的第 <code>grid[row][col]</code> 个单元格。骑士的行动是从下标 <code>0</code> 开始的。</p><p>如果 <code>grid</code> 表示了骑士的有效巡视方案，返回 <code>true</code>；否则返回 <code>false</code>。</p><span id="more"></span><p><strong>注意</strong>，骑士行动时可以垂直移动两个格子且水平移动一个格子，或水平移动两个格子且垂直移动一个格子。下图展示了骑士从某个格子出发可能的八种行动路线。</p><p><img src="/./../../img/topic/%E6%A3%80%E6%9F%A5%E9%AA%91%E5%A3%AB%E5%B7%A1%E8%A7%86%E6%96%B9%E6%A1%88.png"></p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/12/28/yetgriddrawio-5.png"></p><pre><code>输入：grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]输出：true解释：grid 如上图所示，可以证明这是一个有效的巡视方案。</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/12/28/yetgriddrawio-6.png"></p><pre><code>输入：grid = [[0,3,6],[5,8,1],[2,7,4]]输出：false解释：grid 如上图所示，考虑到骑士第 7 次行动后的位置，第 8 次行动是无效的。</code></pre><p><strong>提示：</strong></p><ul><li><code>n == grid.length == grid[i].length</code></li><li><code>3 &lt;= n &lt;= 7</code></li><li><code>0 &lt;= grid[row][col] &lt; n * n</code></li><li><code>grid</code> 中的所有整数 互不相同</li></ul><p><a href="https://leetcode.cn/problems/check-knight-tour-configuration/">点击此去往原题处</a></p><h2 id="解题一：深度遍历搜索"><a href="#解题一：深度遍历搜索" class="headerlink" title="解题一：深度遍历搜索"></a>解题一：深度遍历搜索</h2><pre><code>class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; k&#123;&#123;1,2&#125;,&#123;2,1&#125;,&#123;-1,-2&#125;,&#123;-2,-1&#125;,&#123;-1,2&#125;,&#123;-2,1&#125;,&#123;1,-2&#125;,&#123;2,-1&#125;&#125;;    bool move(vector&lt;vector&lt;int&gt;&gt;&amp; grid,int &amp; x,int &amp; y,int i)&#123;        int n = grid.size();        for (int j = 0;j &lt; 8;++j)&#123;            if (x + k[j][0] &gt;= 0 &amp;&amp; x + k[j][0] &lt; n &amp;&amp; y + k[j][1] &gt;= 0 &amp;&amp; y + k[j][1] &lt; n &amp;&amp; grid[x + k[j][0]][y + k[j][1]] == i)&#123;                x += k[j][0];                y += k[j][1];                return true;            &#125;        &#125;        return false;    &#125;    bool checkValidGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        if (grid[0][0] != 0) return false;        int n = grid.size(), x = 0, y = 0;        for (int i = 1;i &lt; n * n;++i)&#123;            if (!move(grid,x,y,i))&#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(n^2)</code></li><li>空间复杂度：<code>O（1)</code></li></ul><h2 id="解题二：哈希表"><a href="#解题二：哈希表" class="headerlink" title="解题二：哈希表"></a>解题二：哈希表</h2><pre><code>class Solution &#123;public:    bool checkValidGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        if (grid[0][0] != 0) return false;        unordered_map &lt;int,int&gt; hash;        int n = grid.size();        for (int i = 0;i &lt; n;++i)&#123;            for(int j = 0;j &lt; n;++j)&#123;                hash[grid[i][j]] = i * n + j;            &#125;        &#125;        for (int i = 1;i &lt; n*n;++i)&#123;            int dx1 = hash[i] % n, dy1 = hash[i] / n,                dx2 = hash[i - 1] % n, dy2 = hash[i - 1] / n;            if (!((abs(dx1 - dx2) == 1 &amp;&amp; abs(dy1 - dy2) == 2) ||            (abs(dx1 - dx2) == 2 &amp;&amp; abs(dy1 - dy2) == 1)))                return false;        &#125;        return true;    &#125;&#125;;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(n^2)</code></li><li>空间复杂度：<code>O(n)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寻找图中是否存在路径</title>
      <link href="/2022/12/20/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%AF%BB%E6%89%BE%E5%9B%BE%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%B7%AF%E5%BE%84/"/>
      <url>/2022/12/20/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%AF%BB%E6%89%BE%E5%9B%BE%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p>有一个具有 <code>n</code> 个顶点的 双向 图，其中每个顶点标记从 <code>0</code> 到 <code>n - 1</code>（包含 <code>0</code> 和 <code>n - 1</code>）。图中的边用一个二维整数数组 <code>edges</code> 表示，其中 <code>edges[i] = [ui, vi]</code> 表示顶点 <code>ui</code> 和顶点 <code>vi</code> 之间的双向边。 每个顶点对由 最多一条 边连接，并且没有顶点存在与自身相连的边。</p><span id="more"></span><p>请你确定是否存在从顶点 <code>source</code> 开始，到顶点 <code>destination</code> 结束的 有效路径 。</p><p>给你数组 <code>edges</code> 和整数 <code>n、source</code> 和 <code>destination</code>，如果从 <code>source</code> 到 <code>destination</code> 存在 有效路径 ，则返回 <code>true</code>，否则返回 <code>false</code> 。</p><p>示例 1：</p><p><img src="/./../../img/topic/%E5%AF%BB%E6%89%BE%E5%9B%BE%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%B7%AF%E5%BE%84.png"></p><pre><code>输入：n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2输出：true解释：存在由顶点 0 到顶点 2 的路径:- 0 → 1 → 2- 0 → 2</code></pre><p>示例 2：</p><p><img src="/./../../img/topic/%E5%AF%BB%E6%89%BE%E5%9B%BE%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%B7%AF%E5%BE%842.png"></p><pre><code>输入：n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5输出：false解释：不存在由顶点 0 到顶点 5 的路径.</code></pre><p>提示：</p><ul><li>1 &lt;&#x3D; n &lt;&#x3D; 2 * 105</li><li>0 &lt;&#x3D; edges.length &lt;&#x3D; 2 * 105</li><li>edges[i].length &#x3D;&#x3D; 2</li><li>0 &lt;&#x3D; ui, vi &lt;&#x3D; n - 1</li><li>ui !&#x3D; vi</li><li>0 &lt;&#x3D; source, destination &lt;&#x3D; n - 1</li><li>不存在重复边</li><li>不存在指向顶点自身的边</li></ul><h2 id="思路：并查集"><a href="#思路：并查集" class="headerlink" title="思路：并查集"></a>思路：并查集</h2><p>将所有能互相抵达的点都看成一个集合。最终查找点是否在一个集合中。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution &#123;public:    bool validPath(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int source, int destination) &#123;        // 并查集：        int fa[n];        iota(fa, fa + n, 0);        function&lt;int(int)&gt; find = [&amp;](int x)&#123;            return fa[x] == x ? x : fa[x] = find(fa[x]);        &#125;;        auto merge = [&amp;](int from, int to)&#123;            from = find(from);            to = find(to);            if (from != to)                fa[from] = to;        &#125;;        // 合并        for (auto edge : edges) merge(edge[0], edge[1]);        return find(source) == find(destination);    &#125;&#125;;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度： O(n + m) 初始化并查集 n 遍历数组 edges 连接每个点 m 。</li><li>空间复杂度： O(n) 创建并查集的空间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式</title>
      <link href="/2022/12/18/C++/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/12/18/C++/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>Lambda 有很多叫法：Lambda表达式、Lambda函数、匿名函数。</p><span id="more"></span><h2 id="Lambda表达形式："><a href="#Lambda表达形式：" class="headerlink" title="Lambda表达形式："></a>Lambda表达形式：</h2><pre><code>[capture] (params) opt -&gt; ret&#123;body;&#125;;</code></pre><p>其中carpture是捕获列表，params是参数，opt是选项，ret则是返回值的类型，body则是函数的具体实现。</p><ol><li>捕获列表描述了lambda表达式可以访问上下文中的哪些变量。</li></ol><ul><li>[]：表示不捕获任何变量</li><li>[&#x3D;]：表示按值捕获变量</li><li>[&amp;]：表示按引用捕获变量</li><li>[this]：值传递捕获当前的this</li></ul><ol start="2"><li>params表示lambda的参数，用在{}中。</li><li>opt表示lambda的选项。</li><li>ret表示lambda的返回值类型，也可以显示指明返回值类型，lambda会自动推断返回值类型，但是值得注意的是只有当lambda的表达式仅有一条return语句时，自动推断才是有效的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>介绍：并查集</title>
      <link href="/2022/12/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2022/12/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>并查集是一种树型的数据结构，用于处理一些不相交集合（disjoint sets）的合并及查询问题。常常在使用中以森林来表示。</p><span id="more"></span><h2 id="并查集的主要功能："><a href="#并查集的主要功能：" class="headerlink" title="并查集的主要功能："></a>并查集的主要功能：</h2><h3 id="初始化：（init）"><a href="#初始化：（init）" class="headerlink" title="初始化：（init）"></a>初始化：（init）</h3><p>将每个元素初始化只包含自己的集合。</p><h3 id="合并：（-merge-）"><a href="#合并：（-merge-）" class="headerlink" title="合并：（ merge ）"></a>合并：（ merge ）</h3><p>合并两个集合。</p><h3 id="查询：（-find-）"><a href="#查询：（-find-）" class="headerlink" title="查询：（ find ）"></a>查询：（ find ）</h3><p>查询元素所在的集合。</p><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><pre><code>vector&lt;int&gt; father(n), rank(n, 1);// 深度其实可有可无// 初始化：auto init = [&amp;](vector&lt;int&gt; father, vector&lt;int&gt; rank)&#123;    iota(father.bagin(),father.end(),0);    fill(rank.bagin(),rank.end(),1);&#125;;// 查找：function&lt;int(int)&gt; find = [&amp;](int x)&#123;    return father[x] == x ? x : father[x] = find(father[x]);&#125;// 合并：auto merge = [&amp;](int x, int y)&#123;    x = find(x);    y = find(y);    if ( x != y)&#123;        if (rank[x] &lt; rank[y])&#123;            father[x] = y;        &#125;else if (rank[x] &gt; rank[y])&#123;            father[y] = x;        &#125;else&#123;            father[x] = y;            rank[y]++;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过最少操作次数使数组的和相等</title>
      <link href="/2022/12/08/%E7%AE%97%E6%B3%95%E9%A2%98/%E9%80%9A%E8%BF%87%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E7%9B%B8%E7%AD%89/"/>
      <url>/2022/12/08/%E7%AE%97%E6%B3%95%E9%A2%98/%E9%80%9A%E8%BF%87%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E7%9B%B8%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<p>给你两个长度可能不等的整数数组 <code>nums1</code> 和 <code>nums2</code> 。两个数组中的所有值都在 <code>1</code> 到 <code>6</code> 之间（包含 <code>1</code> 和 <code>6</code> ）。</p><p>每次操作中，你可以选择 任意 数组中的任意一个整数，将它变成 <code>1</code> 到 <code>6</code> 之间 任意 的值（包含 <code>1</code> 和 <code>6</code>）。</p><p>请你返回使 <code>nums1</code> 中所有数的和与 <code>nums2</code> 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 <code>-1</code> 。</p><span id="more"></span><p>示例 1：</p><pre><code>输入：nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2]输出：3解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。- 将 nums2[0] 变为 6 。 nums1 = [1,2,3,4,5,6], nums2 = [6,1,2,2,2,2] 。- 将 nums1[5] 变为 1 。 nums1 = [1,2,3,4,5,1], nums2 = [6,1,2,2,2,2] 。- 将 nums1[2] 变为 2 。 nums1 = [1,2,2,4,5,1], nums2 = [6,1,2,2,2,2] 。</code></pre><p>示例 2：</p><pre><code>输入：nums1 = [1,1,1,1,1,1,1], nums2 = [6]输出：-1解释：没有办法减少 nums1 的和或者增加 nums2 的和使二者相等。</code></pre><p>示例 3：</p><pre><code>输入：nums1 = [6,6], nums2 = [1]输出：3解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。- 将 nums1[0] 变为 2 。 nums1 = [2,6], nums2 = [1] 。- 将 nums1[1] 变为 2 。 nums1 = [2,2], nums2 = [1] 。- 将 nums2[0] 变为 4 。 nums1 = [2,2], nums2 = [4] 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 105</code></li><li><code>1 &lt;= nums1[i], nums2[i] &lt;= 6</code></li></ul><h2 id="思路：哈希表-贪心"><a href="#思路：哈希表-贪心" class="headerlink" title="思路：哈希表 + 贪心"></a>思路：哈希表 + 贪心</h2><ol><li>首先考虑特殊情况。无法相等的情况。即一个数组的所有元素为最小值时的和 都比 另一个数组的所有元素为最大时的和 还要大 则说明两数组无法相等。</li><li>计算出两个数组的和所形成的差值。</li><li>用哈希表存储数组元素出现的次数。</li><li>每次操作都采用贪心算法，将每一步优化至最大。</li></ol><p>首先，我们先保证数组一的元素和一定比数组二的大。若第一个更小，则交换数组。</p><p>想要每一步达到最优化，改变第一个数组的 6 ，使其变为 1 ，或改变第二个数组的 1 ，使其 变为 6，两者是等效的。改完 6 ，1 后，改 5 ，2 ，再改 4 ，3 …… 直到 差小于 0 为止。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution &#123;public:    int minOperations(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        int n = nums1.size(), m = nums2.size();        if (n &gt; m * 6|| m &gt; n * 6) return -1;        int diff = accumulate(nums1.begin(),nums1.end(),0)                 - accumulate(nums2.begin(),nums2.end(),0);        if (diff &lt; 0) &#123;            return minOperations(nums2,nums1);        &#125;        vector&lt;int&gt; hash1(7),hash2(7);        for (auto&amp; x : nums1) hash1[x]++;        for (auto&amp; x : nums2) hash2[x]++;                int ans = 0,index = 6;        while (diff &gt; 0)&#123;            if (hash1[index])&#123;                hash1[index]--;            &#125;else if (hash2[7 - index])&#123;                hash2[7 - index]--;            &#125;else &#123;                index--;                continue;            &#125;            ans++;            diff -= index - 1;        &#125;        return ans;    &#125;&#125;;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(m + n)。 遍历数组。</li><li>空间复杂度：O(1)。主要为哈希表的开销。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hash表 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++算法题常用函数、类</title>
      <link href="/2022/12/07/C++/C-%E7%AE%97%E6%B3%95%E9%A2%98%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E3%80%81%E7%B1%BB/"/>
      <url>/2022/12/07/C++/C-%E7%AE%97%E6%B3%95%E9%A2%98%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E3%80%81%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>介绍下 C++ 常用的函数：</p><span id="more"></span><h3 id="STL-容器函数："><a href="#STL-容器函数：" class="headerlink" title="STL 容器函数："></a>STL 容器函数：</h3><p>位于头文件 ‘&lt; numeric &gt;’ 中的函数：</p><h4 id="partial-sum"><a href="#partial-sum" class="headerlink" title="partial_sum():"></a>partial_sum():</h4><p>函数原型：</p><pre><code>OutputIterator partial_sum(InputIterator first, InputIterator last, OutputIterator result);OutputIterator partial_sum(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation binary_op);</code></pre><p>第一个函数：将迭代器的每个元素每个前缀和放至 result 容器中。</p><p>第二个：自定义方式，可以取前缀积什么的。</p><p>例子：</p><pre><code>int list[10] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;int s[10];partial_sum(list, list + 10, s);for (int i = 0;i &lt; 10; i++)&#123;    cout &lt;&lt; s[i] &lt;&lt; &quot; &quot;;&#125;</code></pre><p>输出：</p><pre><code>1 3 6 10 15 21 28 36 45 55</code></pre><h4 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate() :"></a>accumulate() :</h4><p>函数原型：</p><pre><code>T accumulate(InputIterator first, InputIterator last, T init);T accumulate(InputIterator first, InputIterator last, T init，BinaryOperation binary_op);</code></pre><p>第一个函数：将迭代器每个元素相加至 init 中。</p><p>第二个：将迭代器中的每个元素按照 一种方式 计算。</p><p>例子：</p><pre><code>// 求和：int list[10] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;int sum= accumulate(list, list+10, 0) ;// 求乘积：int  con_product = accumulate(list, list + 9, 1, multiplies&lt;int&gt;());// 求双倍和：int myfunction (int x, int y) &#123;return x + 2 * y ;&#125;int dSum = accumulate(list, list+10, 0, myfunction);// 求三倍和：struct myclass &#123;    int operator()(int x, int y) &#123;return x + 3 * y;&#125;&#125; myobject;int tSum = accumulate(list, list+10, 0,myobject);cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;cout &lt;&lt; &quot;dSum = &quot; &lt;&lt; dSum &lt;&lt; endl;cout &lt;&lt; &quot;tSum = &quot; &lt;&lt; tSum &lt;&lt; endl;</code></pre><p>输出：</p><pre><code>sum = 55dSum = 110tSum = 165</code></pre><p>函数实现（假设模板为 int 类型）：</p><pre><code>int accumulate(InputIterator first, InputIterator last, int init , myfunction)&#123;    while (first != last)&#123;        init = myfunction(init , *first);        ++first;    &#125;    return init;&#125;</code></pre><h3 id="单个字符处理："><a href="#单个字符处理：" class="headerlink" title="单个字符处理："></a>单个字符处理：</h3><p>位于头文件 <cctype> 中的函数：</p><p>至于为什么返回类型全是 int ？那是因为这是 C 语言中的函数，由于 C 中没有 boolean 型。故返回类型是 int 且大部分返回的非 0 值为 1 。</p><p>字母大小写转换可以直接用 异或 运算即可以完成转换：<code>c ^= 32</code></p><p>这样，原本是小写的字母则会转换成大写字母，大写的字母会转换成小写字母。</p><h4 id="isdigit"><a href="#isdigit" class="headerlink" title="isdigit() :"></a>isdigit() :</h4><p>函数原型：int isdigit(int c);</p><p>判断字符 c 是否为数字字符 <code>&#39;1&#39; ~ &#39;9&#39;</code><br>若是，则返回 非 0 值（即 true） ，否则返回 0 （即 false）。</p><h4 id="islower"><a href="#islower" class="headerlink" title="islower() :"></a>islower() :</h4><p>函数原型：int islower(int c);</p><p>判断字符 c 是否为小写字母字符 <code>&#39;a&#39; ~ &#39;z&#39;</code><br>若是，则返回 非 0 值（即 true） ，否则返回 0 （即 false）。</p><h4 id="isupper"><a href="#isupper" class="headerlink" title="isupper() :"></a>isupper() :</h4><p>函数原型：int isupper(int c);</p><p>判断字符 c 是否为大写字母字符 <code>&#39;A&#39; ~ &#39;Z&#39;</code><br>若是，则返回 非 0 值（即 true） ，否则返回 0 （即 false）。</p><h4 id="isalpha"><a href="#isalpha" class="headerlink" title="isalpha() :"></a>isalpha() :</h4><p>函数原型：int isalpha(int c);</p><p>判断字符 c 是否为字母字符 <code>&#39;a&#39; ~ &#39;z&#39; || &#39;A&#39; ~ &#39;Z&#39;</code><br>若是，则返回 非 0 值（即 true） ，否则返回 0 （即 false）。</p><h4 id="isalnum"><a href="#isalnum" class="headerlink" title="isalnum() :"></a>isalnum() :</h4><p>函数原型：int isalnum(int c);</p><p>判断字符 c 是否为字母字符或者是数字字符 <code>&#39;a&#39; ~ &#39;z&#39; || &#39;A&#39; ~ &#39;Z&#39; || &#39;1&#39; ~ &#39;9&#39;</code><br>若是，则返回 非 0 值（即 true） ，否则返回 0 （即 false）。</p><h4 id="tolower"><a href="#tolower" class="headerlink" title="tolower() :"></a>tolower() :</h4><p>函数原型：int tolower(int c);</p><p>判断字符 c 是否有大写字母字符<br>若有，则返回 c 的小写字母字符 ，否则返回 原值。</p><h4 id="toupper"><a href="#toupper" class="headerlink" title="toupper() :"></a>toupper() :</h4><p>函数原型：int toupper(int c);</p><p>判断字符 c 是否有小写字母字符<br>若有，则返回 c 的大写字母字符 ，否则返回 原值。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串中不同整数的数目</title>
      <link href="/2022/12/06/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E4%B8%8D%E5%90%8C%E6%95%B4%E6%95%B0%E7%9A%84%E6%95%B0%E7%9B%AE/"/>
      <url>/2022/12/06/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E4%B8%8D%E5%90%8C%E6%95%B4%E6%95%B0%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>给你一个字符串 <code>word</code> ，该字符串由数字和小写英文字母组成。</p><p>请你用空格替换每个不是数字的字符。例如，<code>&quot;a123bc34d8ef34&quot;</code> 将会变成 <code>&quot; 123  34 8  34&quot;</code> 。注意，剩下的这些整数为（相邻彼此至少有一个空格隔开）：<code>&quot;123&quot;</code>、<code>&quot;34&quot;</code>、<code>&quot;8&quot;</code> 和 <code>&quot;34&quot;</code> 。</p><p>返回对 <code>word</code> 完成替换后形成的 不同 整数的数目。</p><p>只有当两个整数的 <strong>不含前导零</strong> 的十进制表示不同， 才认为这两个整数也不同。</p><span id="more"></span><p>示例 1：</p><pre><code>输入：word = &quot;a123bc34d8ef34&quot;输出：3解释：不同的整数有 &quot;123&quot;、&quot;34&quot; 和 &quot;8&quot; 。注意，&quot;34&quot; 只计数一次。</code></pre><p>示例 2：</p><pre><code>输入：word = &quot;leet1234code234&quot;输出：2</code></pre><p>示例 3：</p><pre><code>输入：word = &quot;a1b01c001&quot;输出：1解释：&quot;1&quot;、&quot;01&quot; 和 &quot;001&quot; 视为同一个整数的十进制表示，因为在比较十进制值时会忽略前导零的存在。</code></pre><p>提示：</p><ul><li><code>1 &lt;= word.length &lt;= 1000</code></li><li><code>word</code> 由数字和小写英文字母组成</li></ul><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>将每一个数字 字符串提取出来，然后将 字符串忽略前导 0 ，再存入集合中，最终计算集合元素个数即可。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution &#123;public:    int numDifferentIntegers(string word) &#123;        set&lt;string&gt; ret;        for (int i = 0; i &lt; word.size();i++)&#123;            int head = i;            while (isdigit(word[i])) i++;            while (word[head] == &#39;0&#39; &amp;&amp; head + 1 &lt; i) head++;            string str(word.begin() + head,word.begin() + i);            if (!str.empty())ret.insert(str);        &#125;        return ret.size();    &#125;&#125;;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(n)</code>。遍历了一遍字符串。</li><li>空间复杂的：<code>O(1)</code>。常数级个数的变量。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动所有球到每个盒子所需的最小操作数</title>
      <link href="/2022/12/02/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%A7%BB%E5%8A%A8%E6%89%80%E6%9C%89%E7%90%83%E5%88%B0%E6%AF%8F%E4%B8%AA%E7%9B%92%E5%AD%90%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0/"/>
      <url>/2022/12/02/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%A7%BB%E5%8A%A8%E6%89%80%E6%9C%89%E7%90%83%E5%88%B0%E6%AF%8F%E4%B8%AA%E7%9B%92%E5%AD%90%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>有 <code>n</code> 个盒子。给你一个长度为 <code>n</code> 的二进制字符串 <code>boxes</code> ，其中 <code>boxes[i]</code> 的值为 <code>&#39;0&#39;</code> 表示第 <code>i</code> 个盒子是 空 的，而 <code>boxes[i]</code> 的值为 <code>&#39;1&#39;</code> 表示盒子里有 一个 小球。</p><p>在一步操作中，你可以将 一个 小球从某个盒子移动到一个与之相邻的盒子中。</p><p>返回一个长度为 <code>n</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是将所有小球移动到第 <code>i</code> 个盒子所需的 最小 操作数。</p><p>每个 <code>answer[i]</code> 都需要根据盒子的 初始状态 进行计算。</p><span id="more"></span><p>示例 1：</p><pre><code>输入：boxes = &quot;110&quot;输出：[1,1,3]解释：每个盒子对应的最小操作数如下：1) 第 1 个盒子：将一个小球从第 2 个盒子移动到第 1 个盒子，需要 1 步操作。2) 第 2 个盒子：将一个小球从第 1 个盒子移动到第 2 个盒子，需要 1 步操作。3) 第 3 个盒子：将一个小球从第 1 个盒子移动到第 3 个盒子，需要 2 步操作。将一个小球从第 2 个盒子移动到第 3 个盒子，需要 1 步操作。共计 3 步操作。</code></pre><p>示例 2：</p><pre><code>输入：boxes = &quot;001011&quot;输出：[11,8,5,4,3,4]</code></pre><p>提示：</p><ul><li><code>n == boxes.length</code></li><li><code>1 &lt;= n &lt;= 2000</code></li><li><code>boxes[i]</code> 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><h2 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h2><p>计算出所有的球往右移至一个盒子和往左移至一个盒子的所有值，并将两者相加。</p><p>即：数组 left 保存了将下标 i 的所有左边的球移至 i 中所需要的操作数。<br>数组 right 保存了将下标 i 的所有右边的球移至 i 盒子中所需要的操作数。</p><p>返回数组则为 ： answer &#x3D; left + right;</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution &#123;public:    vector&lt;int&gt; minOperations(string boxes) &#123;        int n = boxes.size();        vector&lt;int&gt; left(n,0),right(n,0),answer(n,0);        for (int i = 1,steps = 0;i &lt; n;i++)&#123;            if (boxes[i - 1] == &#39;1&#39;) steps++; // steps 为步数。            left[i] = left[i - 1] + steps;        &#125;        for (int i = n - 2,steps = 0;i &gt;= 0;i--)&#123;            if (boxes[i + 1] == &#39;1&#39;) steps++;            right[i] = right[i + 1] + steps;        &#125;        for (int i = 0;i &lt; n;i++) answer[i] = right[i] + left[i];        return answer;    &#125;&#125;;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)。三次循环。</li><li>空间复杂度：O(n)。两个数组。</li></ul><h2 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h2><p>我们先将所有球移至第一个盒，计算出操作数。</p><p>移至下个盒子中的操作数就可以看成：在该盒子左边的球都需要往右移一步。右边盒子的球需要倒退一步。这样就只需要了解每个盒子的左边球的个数，以及右边盒子的个数。</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution &#123;public:    vector&lt;int&gt; minOperations(string boxes) &#123;        int left = boxes[0] - &#39;0&#39;, right = 0, operations = 0;        int n = boxes.size();        for (int i = 1; i &lt; n; i++) &#123;            if (boxes[i] == &#39;1&#39;) &#123;                right++;                operations += i;            &#125;        &#125;        vector&lt;int&gt; answer(n);        answer[0] = operations;        for (int i = 1; i &lt; n; i++) &#123;            operations += left - right;            answer[i] = operations;            if (boxes[i] == &#39;1&#39;) &#123;                left++;                right--;            &#125;        &#125;        return answer;    &#125;&#125;;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)。两次次循环。</li><li>空间复杂度：O(1)。常数个数的变量。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大频率栈</title>
      <link href="/2022/12/02/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%9C%80%E5%A4%A7%E9%A2%91%E7%8E%87%E6%A0%88/"/>
      <url>/2022/12/02/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%9C%80%E5%A4%A7%E9%A2%91%E7%8E%87%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出出现频率最高的元素。</p><span id="more"></span><p>实现 <code>FreqStack</code> 类:</p><ul><li><code>FreqStack()</code> 构造一个空的堆栈。</li><li><code>void push(int val)</code> 将一个整数<code> val</code> 压入栈顶。</li><li><code>int pop()</code> 删除并返回堆栈中出现频率最高的元素。</li><li>如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。</li></ul><p>示例 1：</p><pre><code>输入：[&quot;FreqStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;],[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]输出：[null,null,null,null,null,null,null,5,7,5,4]解释：FreqStack = new FreqStack();freqStack.push (5);//堆栈为 [5]freqStack.push (7);//堆栈是 [5,7]freqStack.push (5);//堆栈是 [5,7,5]freqStack.push (7);//堆栈是 [5,7,5,7]freqStack.push (4);//堆栈是 [5,7,5,7,4]freqStack.push (5);//堆栈是 [5,7,5,7,4,5]freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。freqStack.pop ();//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。freqStack.pop ();//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。</code></pre><p>提示：</p><ul><li><code>0 &lt;= val &lt;= 109</code></li><li><code>push</code> 和 <code>pop</code> 的操作数不大于 <code>2 * 104</code>。</li><li>输入保证在调用 <code>pop</code> 之前堆栈中至少有一个元素。</li></ul><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>题目的重点是 <code>pop</code> 函数，完成这个函数有两点：</p><ol><li><p>记录每个元素所出现的次数。</p></li><li><p>记录出现相同次数元素最晚添加进去的元素。</p></li></ol><p>第一点，我们很容易想到使用一组哈希表将每个元素所出现的次数记录下来即可。</p><p>要解决第二点记录最晚出现的元素，那么我们可以创建一个栈，栈顶元素即最晚出现的元素。我们现在将 次数 建立一个栈，每个元素出现 <code>n</code> 次时，该元素就加入至 <code>n</code> 次的这个栈。那么就需要再建立一个将栈放入哈希表的结构。</p><p>做完这两点，完成 <code>pop</code> 函数，只需将最大次数的栈顶元素给删除即可。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>class FreqStack &#123;    unordered_map&lt;int,int&gt; Freq;    unordered_map&lt;int,stack&lt;int&gt;&gt; frequency;    int maxFreq;public:    FreqStack() &#123;        maxFreq = 0;    &#125;        void push(int val) &#123;        Freq[val]++;        frequency[Freq[val]].push(val);        maxFreq = max(maxFreq,Freq[val]);    &#125;        int pop() &#123;        int val = frequency[maxFreq].top();        Freq[val]--;        frequency[maxFreq].pop();        if (frequency[maxFreq].empty()) maxFreq--;        return val;    &#125;&#125;;</code></pre><p><strong>复杂度分析：</strong></p><ul><li><p>时间复杂度：对于 <code>push</code> 和 <code>pop</code> 操作，时间复杂度为 O(1)。</p></li><li><p>空间复杂度：O(n)，其中 n 是 <code>FreqStack</code> 中元素的个数。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生成交替二进制字符串的最少操作数</title>
      <link href="/2022/11/29/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%94%9F%E6%88%90%E4%BA%A4%E6%9B%BF%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%95%B0/"/>
      <url>/2022/11/29/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%94%9F%E6%88%90%E4%BA%A4%E6%9B%BF%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给你一个仅由字符 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的字符串 <code>s</code> 。一步操作中，你可以将任一 <code>&#39;0&#39;</code> 变成 <code>&#39;1&#39;</code> ，或者将 <code>&#39;1&#39;</code> 变成 <code>&#39;0&#39;</code> 。</p><p>交替字符串 定义为：如果字符串中不存在相邻两个字符相等的情况，那么该字符串就是交替字符串。例如，字符串 <code>&quot;010&quot;</code> 是交替字符串，而字符串 <code>&quot;0100&quot;</code> 不是。</p><p>返回使 <code>s</code> 变成 交替字符串 所需的 最少 操作数。</p><span id="more"></span><p>示例 1：</p><pre><code>输入：s = &quot;0100&quot;输出：1解释：如果将最后一个字符变为 &#39;1&#39; ，s 就变成 &quot;0101&quot; ，即符合交替字符串定义。</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;10&quot;输出：0解释：s 已经是交替字符串。</code></pre><p>示例 3：</p><pre><code>输入：s = &quot;1111&quot;输出：2解释：需要 2 步操作得到 &quot;0101&quot; 或 &quot;1010&quot; 。</code></pre><h2 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h2><p>题目要求形成交替字符串，那么最后形成的只可能是 <code>&quot;1010……&quot;</code> 或者 <code>&quot;0101……&quot;</code> 的字符串，所以只需要记录原字符串已经排好位子的字符数量即可，只需要记录一个，然后用总数减去它，就是满足剩下的那个字符串。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution &#123;public:    int minOperations(string s) &#123;        //number 用来记录符合 &quot;1010……&quot; 的数量         int n = s.size(),number = 0;        for (int i = 0;i &lt; n;i++) number += s[i] ^ &#39;0&#39; ^ (i&amp;1);        return min(number,n - number);    &#125;&#125;;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)。n 为字符串长度，遍历一次字符串。</li><li>空间复杂度：O(1)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找到最高海拔</title>
      <link href="/2022/11/19/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%89%BE%E5%88%B0%E6%9C%80%E9%AB%98%E6%B5%B7%E6%8B%94/"/>
      <url>/2022/11/19/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%89%BE%E5%88%B0%E6%9C%80%E9%AB%98%E6%B5%B7%E6%8B%94/</url>
      
        <content type="html"><![CDATA[<p>有一个自行车手打算进行一场公路骑行，这条路线总共由 <code>n + 1</code> 个不同海拔的点组成。自行车手从海拔为 <code>0</code> 的点 <code>0</code> 开始骑行。</p><p>给你一个长度为 <code>n</code> 的整数数组 <code>gain</code> ，其中 <code>gain[i]</code> 是点 <code>i</code> 和点 <code>i + 1</code> 的 净海拔高度差 <code>( 0 &lt;= i &lt; n )</code>。请你返回 最高点的海拔 。</p><span id="more"></span><p>示例 1：</p><pre><code>输入：gain = [-5,1,5,0,-7]输出：1解释：海拔高度依次为 [0,-5,-4,1,1,-6] 。最高海拔为 1 。</code></pre><p>示例 2：</p><pre><code>输入：gain = [-4,-3,-2,-1,4,3,2]输出：0解释：海拔高度依次为 [0,-4,-7,-9,-10,-6,-3,-1] 。最高海拔为 0 。</code></pre><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>用一个变量记录每个位置的海拔。从中选出最高的海拔。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution &#123;public:    int largestAltitude(vector&lt;int&gt;&amp; gain) &#123;        int posHigh = 0,maxAltitude = 0;        for (int i = 0;i &lt; gain.size();i++)&#123;            posHigh +=gain[i];            maxAltitude = max(posHigh,maxAltitude);        &#125;        return maxAltitude;    &#125;&#125;;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(n)</code>。遍历了一遍数组。</li><li>空间复杂的：<code>O(1)</code>。常数级个数的变量。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子序列宽度之和</title>
      <link href="/2022/11/19/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%AD%90%E5%BA%8F%E5%88%97%E5%AE%BD%E5%BA%A6%E4%B9%8B%E5%92%8C/"/>
      <url>/2022/11/19/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%AD%90%E5%BA%8F%E5%88%97%E5%AE%BD%E5%BA%A6%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>一个序列的 宽度 定义为该序列中最大元素和最小元素的差值。</p><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 的所有非空 子序列 的 宽度之和 。由于答案可能非常大，请返回对 <code>1e9 + 7</code> 取余 后的结果。</p><p>子序列 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，<code>[3,6,2,7]</code> 就是数组 <code>[0,3,1,6,2,2,7]</code> 的一个子序列。</p><span id="more"></span><p>示例 1：</p><pre><code>输入：nums = [2,1,3]输出：6解释：子序列为 [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3] 。相应的宽度是 0, 0, 0, 1, 1, 2, 2 。宽度之和是 6 。</code></pre><p>示例 2：</p><pre><code>输入：nums = [2]输出：0</code></pre><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h2><p>由于题目要求任意子序列，则与元素所在的位置无关，所以先将序列排序。</p><p>排序之后就是求子序列的宽度了，那么我们现在就是要求每个元素对这个子序列宽度的贡献值。</p><p>若他为子序列中的最小值，则他的贡献值为负；</p><p>若为最大值，则贡献值为正。</p><p>排序之后的数组 nums 很容易知道元素 <code>nums[i]</code> 比他小的有 <code>i</code> 个元素，若他为子序列最大值，则可以在 <code>2 ^ i</code> 个子序列充当最大值。若他为最小值，则可以在 <code>2 ^ ( n - i - 1 )</code> 个子序列中牌最小值。</p><p>故该元素的贡献值为：<code>( 2 ^ ( n - i - 1 ) - 2 ^ i ) * nums[i] </code></p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution &#123;public:    int sumSubseqWidths(vector&lt;int&gt;&amp; nums) &#123;        int n = nums.size();        long res = 0,mod = 1e9 + 7;         sort(nums.begin(),nums.end());        vector&lt;long&gt; Pow(n,1);        for (int i = 1;i &lt; n;i++)Pow[i] = (Pow[i-1]&lt;&lt;1)%mod;        for (int i = 0;i &lt; n;i++)&#123;            res = (res + (Pow[i] - Pow[n-i-1]) * nums[i])%mod;        &#125;        return res;    &#125;&#125;;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (nlogn)</code>。该代码为，排序的时间复杂度 O(nlogn) 。</li><li>空间复杂度：<code>O (n)</code>。 创建了个 Pow 数组，来缩短运行时间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全局倒置与局部倒置</title>
      <link href="/2022/11/16/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%85%A8%E5%B1%80%E5%80%92%E7%BD%AE%E4%B8%8E%E5%B1%80%E9%83%A8%E5%80%92%E7%BD%AE/"/>
      <url>/2022/11/16/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%85%A8%E5%B1%80%E5%80%92%E7%BD%AE%E4%B8%8E%E5%B1%80%E9%83%A8%E5%80%92%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>给你一个长度为 n 的整数数组 nums ，表示由范围 [0, n - 1] 内所有整数组成的一个排列。</p><span id="more"></span><p>全局倒置 的数目等于满足下述条件不同下标对 (i, j) 的数目：</p><ul><li>0 &lt;&#x3D; i &lt; j &lt; n</li><li>nums[i] &gt; nums[j]</li></ul><p>局部倒置 的数目等于满足下述条件的下标 i 的数目：</p><ul><li>0 &lt;&#x3D; i &lt; n - 1</li><li>nums[i] &gt; nums[i + 1]</li></ul><p>当数组 nums 中 全局倒置 的数量等于 局部倒置 的数量时，返回 true ；否则，返回 false 。</p><p>示例 1：</p><pre><code>输入：nums = [1,0,2]输出：true解释：有 1 个全局倒置，和 1 个局部倒置。</code></pre><p>示例 2：</p><pre><code>输入：nums = [1,2,0]输出：false解释：有 2 个全局倒置，和 1 个局部倒置。</code></pre><h2 id="思路一：维护后缀最小值"><a href="#思路一：维护后缀最小值" class="headerlink" title="思路一：维护后缀最小值"></a>思路一：维护后缀最小值</h2><p>由于局部导致也属于是全局倒置，只要找出一对是属于全局倒置但不属于局部倒置即可。</p><ol><li>遍历至 nums[i] 时，只需要找到在后面有没有比 nums[i] 更小的元素即可。</li><li>所以我们从后往前遍历，保存后缀数组的最小值并与 nums[i] 进行比较即可。</li></ol><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution &#123;public:    bool isIdealPermutation(vector&lt;int&gt;&amp; nums) &#123;        int n = nums.size(), minSuff = nums[n - 1];        for (int i = n - 3; i &gt;= 0; i--) &#123;            if (nums[i] &gt; minSuff) &#123;                return false;            &#125;            minSuff = min(minSuff, nums[i + 1]);        &#125;        return true;    &#125;&#125;;</code></pre><h2 id="思路二：数学归纳"><a href="#思路二：数学归纳" class="headerlink" title="思路二：数学归纳"></a>思路二：数学归纳</h2><p>由于这个数组 nums 是由 [0 ~ n-1] 组成的排列。</p><p>假设数组的全局倒置和局部倒置相等。则有：</p><p>他的值与下标差不能大于 1 。</p><ol><li>若 nums[0] &#x3D; 0。则将原来的 [0,n-1] 即可看成 [1,n-1] 的问题</li><li>若 nums[1] &#x3D; 0。则 nums[0] 一定为 1 。若不为 1 ，则在 下标为 1 的后面一定有一个数为 1 。则就不满足全局倒置和局部倒置相等了。则剩下的则可以看成 [2,n-1] 的问题。</li></ol><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution &#123;public:    bool isIdealPermutation(vector&lt;int&gt;&amp; nums) &#123;        for (int i = 0; i &lt; nums.size(); i++) &#123;            if (nums[i] - i &gt; 1 || nums[i] - i &lt; 1) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自定义字符串排序</title>
      <link href="/2022/11/13/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/11/13/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>给定两个字符串 <code>order</code> 和 <code>s</code> 。<code>order</code> 的所有单词都是 唯一 的，并且以前按照一些自定义的顺序排序。</p><p>对 <code>s</code> 的字符进行置换，使其与排序的 <code>order</code> 相匹配。更具体地说，如果在 <code>order</code> 中的字符 <code>x</code> 出现字符 <code>y</code> 之前，那么在排列后的字符串中， <code>x</code> 也应该出现在 <code>y</code> 之前。</p><p>返回 满足这个性质的 <code>s</code> 的任意排列 。</p><span id="more"></span><p>示例 1:</p><pre><code>输入: order = &quot;cba&quot;, s = &quot;abcd&quot;输出: &quot;cbad&quot;解释: “a”、“b”、“c”是按顺序出现的，所以“a”、“b”、“c”的顺序应该是“c”、“b”、“a”。因为“d”不是按顺序出现的，所以它可以在返回的字符串中的任何位置。“dcba”、“cdba”、“cbda”也是有效的输出。</code></pre><p>示例 2:</p><pre><code>输入: order = &quot;cbafg&quot;, s = &quot;abcd&quot;输出: &quot;cbad&quot;</code></pre><p>提示:</p><p><code>1 &lt;= order.length &lt;= 26</code><br><code>1 &lt;= s.length &lt;= 200</code><br><code>order</code> 和 <code>s</code> 由小写英文字母组成<br><code>order</code> 中的所有字符都 不同</p><h2 id="思路：计数排序"><a href="#思路：计数排序" class="headerlink" title="思路：计数排序"></a>思路：计数排序</h2><p>主要分为这几步：</p><ol><li>将 <code>order</code> 字符串中存在的 字符全用 <code>hash</code> 表记录下来。</li><li>将 <code>s</code> 遍历，计数 <code>order</code> 字符串每个在 <code>s</code> 中出现的个数，并将 <code>s</code> 中未出现在 <code>order</code> 中的字符先输入到 <code>ans</code> 中。</li><li>按照 <code>order</code> 字符串顺序输入至 <code>ans</code> 中。</li></ol><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">customSortString</span>(<span class="params"><span class="built_in">string</span> order, <span class="built_in">string</span> s</span>)</span> &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="built_in">int</span>&gt; <span class="title">hash</span>(<span class="params"><span class="number">26</span></span>)</span>;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">char</span> ch : order)hash[ch - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">char</span> ch : s)&#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[ch - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">                hash[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">char</span> ch : order)</span><br><span class="line">            <span class="keyword">while</span> (hash[ch - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                ans += ch;</span><br><span class="line">                hash[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度： O(n) , 遍历每个字符串一次，然后输出给字符串 ans 。</li><li>空间复杂度： O(1) ，简单定义了个 hash 表。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hash表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：矩阵快速幂</title>
      <link href="/2022/11/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/2022/11/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<p>矩阵快速幂通常是用来降低动态规划的一个算法</p><span id="more"></span><h2 id="聊下快速幂："><a href="#聊下快速幂：" class="headerlink" title="聊下快速幂："></a>聊下快速幂：</h2><p>先看下下面两个函数：</p><pre><code>int pow(int a,int n)&#123;    int ret = 1;    while (n--)&#123;        ret *= a;    &#125;    return ret;&#125;int quickPow(int a,int n)&#123;    int ret = 1;    int temp = a;    while (n)&#123;        if (n&amp;1) ret *= temp;        temp *= temp;        n &gt;&gt;= 1;    &#125;    return ret;&#125;</code></pre><p>通常我们求一个数的 <code>n</code> 次方，自己笔算一般都是按照第一个函数 <code>pow</code> 的算法进行计算，那么就需要<code>O(n)</code> 的时间复杂度。那么现在快速幂就是第二种函数 <code>quickPow</code> ，它将这个时间复杂度降到了 <code>O(logn)</code> 。</p><p>具体先来看下函数 <code>quickPow</code> 如何求 2 的 47 次方的：</p><p>首先把 2<sup>47</sup> 的 47 看成用二进制数 101111。</p><p>也就有： 2<sup>101111</sup> &#x3D; 2<sup>100000</sup> _ 2<sup>1000</sup> _ 2<sup>100</sup> _ 2<sup>10</sup> _ 2<sup>1</sup></p><p>原数即：2<sup>47</sup> &#x3D; 2<sup>32</sup> _ 2<sup>8</sup> _ 2<sup>4</sup> _ 2<sup>2</sup> _ 2<sup>1</sup></p><p>现在用 <code>temp</code> 这个变量保存从低位到高位的每一个次方值。</p><p>现在将二进制数 <code>101111</code> 看成位图。</p><p>将二进制数进行右移一位，个位为 <code>1</code> 的位 <code>temp</code> 就乘进去，为 <code>0</code> 的那位就跳过。直至二进制数为 <code>0</code> 。</p><h2 id="矩阵快速幂的实际运用："><a href="#矩阵快速幂的实际运用：" class="headerlink" title="矩阵快速幂的实际运用："></a>矩阵快速幂的实际运用：</h2><p>斐波那契数列很容易想到用递归或者动态规划进行求第 n 项。那么我们现在用矩阵快速幂来看看，这个怎么求：</p><p>斐波那契数列：a<sub>1</sub> ，a<sub>2</sub> ，a<sub>3</sub> ，a<sub>4</sub> …… a<sub>n</sub></p><p>有以下这个公式：</p><blockquote><p>a<sub>n</sub> &#x3D; a<sub>n - 1</sub> + a<sub>n - 2</sub>;</p></blockquote><p>那么我们现在看下面的矩阵乘法：</p><p><img src="/./../../img/algorithm/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82.png"></p><p>现在可以把 a<sub>n - 1</sub> 和 a<sub>n - 2</sub> 分别看成 A 和 B ，那么右边的 A + B 就成了 a<sub>n</sub> 。</p><p>用此递推公式就可以利用第一项求出第 n 项。</p><p><img src="/./../../img/algorithm/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%821.png"></p><p>这样就只需要求左边矩阵的 n 次幂。</p><p>现在就是求矩阵的快速幂，将原来的底数换成了矩阵。</p><p>现在来看下该矩阵的快速幂函数：</p><pre><code>// 矩阵乘法函数vector&lt;vector&lt;long long&gt;&gt; matrixMultiply (vector&lt;vector&lt;long long&gt;&gt;&amp; matrix1, vector&lt;vector&lt;long long&gt;&gt;&amp; matrix2)&#123;    int n = matrix1.size(), m = matrix2.size(), l = matrix2[0].size();    vector&lt;vector&lt;long long &gt;&gt; ret(n, vector&lt;long long&gt;(l,0));    for (int i = 0;i &lt; n;++i)&#123;        for (int j = 0;j &lt; l; ++j)&#123;            for (int k = 0; k &lt; m;++k)&#123;                ret[i][j] += matrix1[i][k] * matrix2[k][j];            &#125;        &#125;&#125;return ret;&#125;// 矩阵快速幂函数：vector&lt;vector&lt;long long&gt;&gt; matrixQuickPower (vector&lt;vector&lt;long long&gt;&gt;&amp; matrix, long long n)&#123;    int r = (int)matrix.size();    vector&lt;vector&lt;long long&gt;&gt; ret(r,vector&lt;long long&gt;(r, 0)), temp = matrix;    for (int i = 0; i &lt; r; ++i) &#123;        ret[i][i] = 1;    &#125;    while (n &gt; 0)&#123;        if (n &amp; 1) ret = matrixMultiply(temp, ret);        temp = matrixMultiply(temp, temp);        n &gt;&gt;= 1;    &#125;    return ret;&#125;// 斐波那契数列第 n 项数值。int fibonacciSequence(int n)&#123;    vector&lt;vector&lt;long&gt;&gt; ret&#123;&#123;1,1&#125;,&#123;1,0&#125;&#125;;    vector&lt;vector&lt;long&gt;&gt; res = matrixQuickPow(ret,n);    return res[0][0];&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(logn)</code> 。</li><li>空间复杂度：<code>O(1)</code> 。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多米诺和托米诺平铺</title>
      <link href="/2022/11/12/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/"/>
      <url>/2022/11/12/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/</url>
      
        <content type="html"><![CDATA[<p>有两种形状的瓷砖：一种是 <code>2 x 1</code> 的多米诺形，另一种是形如 <code>&quot;L&quot;</code> 的托米诺形。两种形状都可以旋转。</p><p><img src="/./../../img/topic/%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA1.png"></p><p>给定整数 <code>n</code> ，返回可以平铺 <code>2 x n</code> 的面板的方法的数量。返回对 <code>109 + 7</code> 取模 的值。</p><p>平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。</p><span id="more"></span><p><strong>示例 1:</strong></p><p><img src="/./../../img/topic/%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA2.png"></p><pre><code>输入: n = 3输出: 5解释: 五种不同的方法如上所示。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: n = 1输出: 1</code></pre><h2 id="思路一：动态规划"><a href="#思路一：动态规划" class="headerlink" title="思路一：动态规划"></a>思路一：动态规划</h2><p>用数组 dp 记录铺至 2 * i 的时的状态。</p><p>每次铺至 i 位置时，都有以下情况。</p><ul><li>一个正方形都没有被覆盖，记为状态 0；(1 表示已经铺了面板,0 表示还未铺面板)<blockquote><pre><code> i-1   i     i+1  1    0      0  1    0      0</code></pre></blockquote></li><li>只有上方的正方形被覆盖，记为状态 1；<blockquote><pre><code> i-1   i     i+1  1    1      0  1    0      0</code></pre></blockquote></li><li>只有下方的正方形被覆盖，记为状态 2；<blockquote><pre><code> i-1   i     i+1  1    0      0  1    1      0</code></pre></blockquote></li><li>上下两个正方形都被覆盖，记为状态 3。<blockquote><pre><code> i-1   i     i+1  1    1      0  1    1      0</code></pre></blockquote></li></ul><p>现在分析铺至第 i 位每种情况都可以由 i - 1 时的哪个状态到达。</p><ul><li><p>状态 0 ：只能由状态 3 什么板都不铺 所得。</p></li><li><p>状态 1 ：可以由 i-1 时的 状态 0 和状态 2 铺得。</p><blockquote><pre><code>i-1     i             i-1      i 0      0      —&gt;      1       1 0      0              1       0</code></pre><p>或<br>i-1     i             i-1      i<br> 0      0      —&gt;      1       1<br> 1      0              1       0</p></blockquote></li><li><p>状态 2 ：可以由 i-1 时的 状态 0 和状态 1 铺得。</p><blockquote><pre><code>i-1     i             i-1      i 0      0      —&gt;      1       0 0      0              1       1</code></pre><p>或<br>i-1     i             i-1      i<br> 1      0      —&gt;      1       0<br> 0      0              1       1</p></blockquote></li><li><p>状态 3 ：可以由 i-1 时的 状态 0 、状态 1 、状态 2 和 状态 3 铺得。</p><blockquote><pre><code>i-1     i             i-1      i 0      0      —&gt;      1       1 0      0              1       1</code></pre><p>或<br>i-1     i             i-1      i<br> 0      0      —&gt;      1       1<br> 1      0              1       1<br>或<br>i-1     i             i-1      i<br> 0      0      —&gt;      1       1<br> 1      0              1       1<br>或<br>i-1     i             i-1      i<br> 1      0      —&gt;      1       1<br> 1      0              1       1</p></blockquote></li></ul><p>所以可以得到递推公式 ：</p><p>初态： dp[0][0] &#x3D; 0 ,dp[0][1] &#x3D; 0,dp[0][2] &#x3D; 0,dp[0][3] &#x3D; 1;</p><pre><code>dp[i][0] = dp[i-1][3];dp[i][1] = dp[i-1][0] + dp[i-1][2];dp[i][2] = dp[i-1][0] + dp[i-1][1];dp[i][3] = dp[i-1][0] + dp[i-1][1] + dp[i-1][2] + dp[i-1];</code></pre><p>铺至 n 时 dp[n][3] 即是答案。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution &#123;public:    int numTilings(int n) &#123;        int mod = int(1e9 + 7);        vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(4));        dp[0][3] = 1;        for (int i = 1;i &lt;= n;i++)&#123;            dp[i][0] = dp[i-1][3];            dp[i][1] = (dp[i-1][0] + dp[i-1][2])%mod;            dp[i][2] = (dp[i-1][0] + dp[i-1][1])%mod;            dp[i][3] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][2] + dp[i-1][3])%mod;        &#125;        return dp[n][3];    &#125;&#125;;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(n)</code> 经历了个 for 循环。</li><li>空间复杂度：<code>O(n)</code> 创建了个数组 dp 用来搞动态规划方程。</li></ul><h2 id="思路二：矩阵快速幂"><a href="#思路二：矩阵快速幂" class="headerlink" title="思路二：矩阵快速幂"></a>思路二：矩阵快速幂</h2><p>关于 <a href="./../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%EF%BC%9A%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82.md">矩阵快速幂</a> 可以点击看他的解读。</p><p>每一列的 dp 第 i 都可以用 i - 1 表示，所以就可以相当于前一列左乘一个方阵 A ，乘以一个方阵 A 就等于 i 增加了 1 。故要求 n 时的摆放位置，只是左乘 n 个方阵 A 。</p><pre><code>        ⎡ 0  0  0  1 ⎤A   =     1  0  1  0          1  1  0  1        ⎣ 1  1  1  1 ⎦</code></pre><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution &#123;public:    int mod = 1e9 + 7;    // 矩阵乘法    vector&lt;vector&lt;long&gt;&gt; matrixMultiply(vector&lt;vector&lt;long&gt;&gt; &amp;a,vector&lt;vector&lt;long&gt;&gt; &amp;b)&#123;        vector &lt;vector&lt;long&gt;&gt; ret&#123;&#123;0,0,0,0&#125;,&#123;0,0,0,0&#125;,&#123;0,0,0,0&#125;,&#123;0,0,0,0&#125;&#125;;        for (int i = 0;i &lt; 4;i++)&#123;            for (int j = 0;j &lt; 4;j++)&#123;                for (int k = 0;k &lt; 4;k++)&#123;                    ret[i][j] = (ret[i][j] + a[i][k] * b[k][j])%mod;                &#125;            &#125;        &#125;        return ret;    &#125;    // 矩阵快速幂函数：    vector&lt;vector&lt;long&gt;&gt; matrixQuickPow(vector&lt;vector&lt;long&gt;&gt; &amp;a,int n)&#123;        vector&lt;vector&lt;long&gt;&gt; ret&#123;&#123;1,0,0,0&#125;,&#123;0,1,0,0&#125;,&#123;0,0,1,0&#125;,&#123;0,0,0,1&#125;&#125;;//单位矩阵        while (n)&#123;            if (n&amp;1)ret = matrixMultiply(ret,a);            a = matrixMultiply(a,a);            n &gt;&gt;= 1;        &#125;        return ret;    &#125;    int numTilings(int n) &#123;        vector&lt;vector&lt;long&gt;&gt; ret&#123;&#123;0,0,0,1&#125;,&#123;1,0,1,0&#125;,&#123;1,1,0,0&#125;,&#123;1,1,1,1&#125;&#125;;        vector&lt;vector&lt;long&gt;&gt; res = matrixQuickPow(ret,n);        return res[3][3];    &#125;&#125;;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(logn)</code></li><li>空间复杂度：<code>O(1)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵快速幂 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开始C++</title>
      <link href="/2022/11/09/C++/%E5%BC%80%E5%A7%8BC++/"/>
      <url>/2022/11/09/C++/%E5%BC%80%E5%A7%8BC++/</url>
      
        <content type="html"><![CDATA[<p>现在开始 c++ 的学习，因为发现 c 库中的函数太少，自己又比较的懒，自己不愿封装函数，又看到他人的代码那么简洁，所以开始了 C++ 学习。接下来粗略的记录一些 c++ 与 c 不同的地方。</p><span id="more"></span><h2 id="进入C"><a href="#进入C" class="headerlink" title="进入C++"></a>进入C++</h2><p>C 语言的所有语句都能放在 C++ 中运行。C++ 对 C 语言中的很多语句进行了补充。</p><h3 id="main-函数："><a href="#main-函数：" class="headerlink" title="main 函数："></a>main 函数：</h3><p>在 C 语言中每个 main 函数都要在结尾添加 return 0; 语句以便给操作系统检查，该程序是否运行出错。由于程序员要在 C 中每个 main 函数都要填加 return 0; 给许多的程序员造成了一定的烦恼。所以 C++ 编译器让程序员可以不用输入 return 0; 在程序运行时自动添加上 return 0; 语句。</p><h3 id="输入输出语句："><a href="#输入输出语句：" class="headerlink" title="输入输出语句："></a>输入输出语句：</h3><p>C 中的输入输出是以函数的形式存在。C++ 增加了流的概念，将输入设备和输出设备看成一个流。</p><p>在 C++ 中：</p><pre><code>cout &lt;&lt; endl;   // endl 与 &quot;\n&quot; 等价。cin &gt;&gt; x ;      // x 为变量。//&lt;&lt; 和 &gt;&gt; 表示了设备流的流向</code></pre><h3 id="字符串读取："><a href="#字符串读取：" class="headerlink" title="字符串读取："></a>字符串读取：</h3><p>在 C++ 中：</p><pre><code>cin.getline();cin.get();//两者区别：//getline() : 读取一行到换行符为止，然后将换行符丢弃。//get() : 读取一行到换行符为止，然后将换行符保留在输入流中。</code></pre><h3 id="赋值："><a href="#赋值：" class="headerlink" title="赋值："></a>赋值：</h3><p>在 C++ 中：</p><pre><code>int x = 5;  //与下面的全都等价。int x(5);int x&#123;5&#125;;int x = &#123;5&#125;;</code></pre><h3 id="引入头文件"><a href="#引入头文件" class="headerlink" title="引入头文件"></a>引入头文件</h3><p>C 中的头文件都是 <code>&lt;string.h&gt;</code> 有个 <code>.h</code> 结尾。在 C++ 中将这些头文件进行了改变。改成了前缀 c 。例如：<code>&lt;cstring&gt;</code></p><h3 id="auto-的重新定义："><a href="#auto-的重新定义：" class="headerlink" title="auto 的重新定义："></a>auto 的重新定义：</h3><p>C 语言中 auto 是一个关键字，在 C++ 中 auto 是一个自动类型推断功能。</p><p>如：</p><pre><code>auto x = 0;         // x 的数据类型就会被指定为 int auto y = 0.0;       // y 的数据类型就会被指定为 doubleauto z = 1.3e12L;   // z 的数据类型就会被指定为 long</code></pre><h3 id="强制转换："><a href="#强制转换：" class="headerlink" title="强制转换："></a>强制转换：</h3><p>将一个数据类型进行强制转换：</p><pre><code>(typeName) value;    // C中的typeName (value);    // C++ 中新增的</code></pre><p>C++ 中的格式让读者看起来像是使用了一个函数。</p><p>推广：</p><pre><code>static_cast&lt;typeName&gt; (value);</code></pre><h3 id="结构体："><a href="#结构体：" class="headerlink" title="结构体："></a>结构体：</h3><p>在 C++ 中减少了 typedef 的使用。</p><p>代码：</p><pre><code>struct guest &#123;    char name[20];    float weight;&#125;;// 想要申请结构可以省略 struct guest g ;</code></pre><p>C++ 中的结构体也满足赋值的赋值形式：</p><pre><code>guest g &#123;&quot;caoxing&quot;,60&#125;;     //这样就是一一对于结构体里面的值</code></pre><h3 id="指针："><a href="#指针：" class="headerlink" title="指针："></a>指针：</h3><p>C++ 新添了 new 语句。可以替代 c 中的 malloc 。</p><pre><code>int* x = (int*) malloc(sizeof(int)); //可以用下面语句代替。int* x = new int;//数组：int* x = (int*) malloc(sizeof(int) * 10);   //可以用下面语句代替int* x = new int [10];</code></pre><p>但是在 C++ 中使用的 new 分配内存一定要配对一个 delete ;</p><pre><code>int* ps = new int; ...delete ps; // ps 还是可以使用，只是删除了 new 分配的内存。</code></pre><h2 id="C-中的-一些类"><a href="#C-中的-一些类" class="headerlink" title="C++ 中的 一些类"></a>C++ 中的 一些类</h2><h3 id="string-类："><a href="#string-类：" class="headerlink" title="string 类："></a>string 类：</h3><p>string类 是一种字符串的替代品。</p><pre><code>string str1;       //定义一个 str1 对象、以动态分配内存，不需要指明大小。string str2 = &quot;jaguar&quot;;string str3 = &quot;ocelot&quot;;str1 = str2 + str3; // 可以用 + 拼接两个 string 对象str2 += str3;       // 这样也是可以的</code></pre><p>string类 的 I&#x2F;O：</p><pre><code>string str;         // 起初创建时，str 的长度为 0 getline(cin,str);   // 从输入流中得到一个字符串。cout &lt;&lt; str.size(); // 输出 str 的长度</code></pre><h3 id="vector-类-和-array-类："><a href="#vector-类-和-array-类：" class="headerlink" title="vector 类 和 array 类："></a>vector 类 和 array 类：</h3><p>模板类 vector 和 array 是数组的替代品。</p><ul><li>模板类 vector ：</li></ul><p>模板类 vector 和 string 类相似，都是动态分配内存。</p><pre><code>vector&lt;typeName&gt; vt(n_elem);     // vt 是一个 vector&lt;typeName&gt; 对象,储存的个数为 n_elem // 在插入 或者添加时会自动调整长度。</code></pre><ul><li>模板类 array ：</li></ul><p>它是 C++ 11 新增的一个类。相比于 vector 类，他是一个静态内存分配的类，vector 形成动态分配产生了代价，使得其效率比较低。所以 array 对象 与数组一样，长度固定，效率和数组一样，但更方便、更安全。</p><p>下面声明创建一个名为 arr 的 array 对象，它包含 n_elem 个类型为 typeName 的元素。</p><pre><code>array&lt;typeName, n_elem&gt; arr;    // n_elem 不能为变量// 也可以初始化变量array&lt;double, 4&gt; ad = &#123;1.2, 2.1, 3.43, 4.3&#125;;</code></pre><p>数组、vector 对象 、 array 对象 的相同与不同：</p><ul><li><p>相同点： 都可以用标准的数组表示法来访问各个元素。</p></li><li><p>不同点：</p></li></ul><ol><li>array 对象和 数组都保存在 栈内存 中，vector 对象保存在 堆内存 或者 自由存储区 中。</li><li>array 对象可以直接赋值给另一个对象，而对于数组只能逐元素赋值。</li></ol><p>数组 、 vector 对象 和 array 对象 的 for 循环（类似于java 的 for - each 循环）：</p><pre><code>double prices[5] = &#123;4.99, 10.99, 6.87, 7.99, 8.49&#125;for (double x : prices)&#123;    cout &lt;&lt; x &lt;&lt; endl ;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>统计一致字符串的数目</title>
      <link href="/2022/11/08/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%BB%9F%E8%AE%A1%E4%B8%80%E8%87%B4%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE/"/>
      <url>/2022/11/08/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%BB%9F%E8%AE%A1%E4%B8%80%E8%87%B4%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>给你一个由不同字符组成的字符串 <code>allowed</code> 和一个字符串数组 <code>words</code> 。如果一个字符串的每一个字符都在 <code>allowed</code> 中，就称这个字符串是 <strong>一致字符串</strong> 。</p><p>请你返回 <code>words</code> 数组中 <strong>一致字符串</strong> 的数目。</p><span id="more"></span><p>示例 1：</p><pre><code>输入：allowed = &quot;ab&quot;, words = [&quot;ad&quot;,&quot;bd&quot;,&quot;aaab&quot;,&quot;baa&quot;,&quot;badab&quot;]输出：2解释：字符串 &quot;aaab&quot; 和 &quot;baa&quot; 都是一致字符串，因为它们只包含字符 &#39;a&#39; 和 &#39;b&#39; 。</code></pre><p>示例 2：</p><pre><code>输入：allowed = &quot;abc&quot;, words = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;ab&quot;,&quot;ac&quot;,&quot;bc&quot;,&quot;abc&quot;]输出：7解释：所有字符串都是一致的。</code></pre><p>示例 3：</p><pre><code>输入：allowed = &quot;cad&quot;, words = [&quot;cc&quot;,&quot;acd&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bac&quot;,&quot;bad&quot;,&quot;ac&quot;,&quot;d&quot;]输出：4解释：字符串 &quot;cc&quot;，&quot;acd&quot;，&quot;ac&quot; 和 &quot;d&quot; 是一致字符串。</code></pre><p>提示：</p><ul><li><code>1 &lt;= words.length &lt;= 104</code></li><li><code>1 &lt;= allowed.length &lt;= 26</code></li><li><code>1 &lt;= words[i].length &lt;= 10</code></li><li><code>allowed</code> 中的字符 互不相同 。</li><li><code>words[i]</code> 和 <code>allowed</code> 只包含小写英文字母。</li></ul><h2 id="思路：hash表"><a href="#思路：hash表" class="headerlink" title="思路：hash表"></a>思路：hash表</h2><p>将 <code>allowed</code> 中所有出现过的字母保存至一个哈希表中，然后遍历 <code>words</code> 中的每一个字符串，判断是否存在 不在 <code>allowed</code> 中的字母。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>int countConsistentStrings(char * allowed, char ** words, int wordsSize)&#123;    int hash[26] = &#123;0&#125;,m = strlen(allowed),num = 0,i;    for (i = 0;i &lt; m;i++)&#123;        hash[allowed[i] - &#39;a&#39;] = 1;    &#125;    for (i = 0;i &lt; wordsSize;i++)&#123;        for (int j = 0;words[i][j];j++)&#123;            if (hash[words[i][j] - &#39;a&#39;] == 0)&#123;                num--;                break;            &#125;        &#125;        num++;    &#125;    return num;&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(n)</code> 。<code>n</code> 为 <code>words</code> 中字符的个数。</li><li>空间复杂度：<code>O(1)</code> 。仅申请了一个大小为 26 的哈希表 和一些变量。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hash表 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模糊坐标</title>
      <link href="/2022/11/07/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%A8%A1%E7%B3%8A%E5%9D%90%E6%A0%87/"/>
      <url>/2022/11/07/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%A8%A1%E7%B3%8A%E5%9D%90%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<p>我们有一些二维坐标，如 <code>&quot;(1, 3)&quot;</code> 或 <code>&quot;(2, 0.5)&quot;</code>，然后我们移除所有逗号，小数点和空格，得到一个字符串S。返回所有可能的原始字符串到一个列表中。</p><p>原始的坐标表示法不会存在多余的零，所以不会出现类似于<code>&quot;00&quot;</code>, <code>&quot;0.0&quot;</code>, <code>&quot;0.00&quot;</code>, <code>&quot;1.0&quot;</code>, <code>&quot;001&quot;</code>, <code>&quot;00.01&quot;</code>或一些其他更小的数来表示坐标。此外，一个小数点前至少存在一个数，所以也不会出现<code>“.1”</code>形式的数字。</p><p>最后返回的列表可以是任意顺序的。而且注意返回的两个数字中间（逗号之后）都有一个空格。</p><span id="more"></span><p>示例 1:</p><pre><code>输入: &quot;(123)&quot;输出: [&quot;(1, 23)&quot;, &quot;(12, 3)&quot;, &quot;(1.2, 3)&quot;, &quot;(1, 2.3)&quot;]</code></pre><p>示例 2:</p><pre><code>输入: &quot;(00011)&quot;输出:  [&quot;(0.001, 1)&quot;, &quot;(0, 0.011)&quot;]解释: 0.0, 00, 0001 或 00.01 是不被允许的。</code></pre><p>示例 3:</p><pre><code>输入: &quot;(0123)&quot;输出: [&quot;(0, 123)&quot;, &quot;(0, 12.3)&quot;, &quot;(0, 1.23)&quot;, &quot;(0.1, 23)&quot;, &quot;(0.1, 2.3)&quot;, &quot;(0.12, 3)&quot;]</code></pre><p>示例 4:</p><pre><code>输入: &quot;(100)&quot;输出: [(10, 0)]解释: 1.0 是不被允许的。</code></pre><p>提示:</p><ul><li><code>4 &lt;= S.length &lt;= 12.</code></li><li><code>S[0] = &quot;(&quot;, S[S.length - 1] = &quot;)&quot;</code>, 且字符串 <code>S</code> 中的其他元素都是数字。</li></ul><h2 id="思路：-穷举"><a href="#思路：-穷举" class="headerlink" title="思路： 穷举"></a>思路： 穷举</h2><p>先将字符串 <code>s</code> 分为两个部分，即在中间加个逗号。然后再穷举左右两边加小数点的情况。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>//该函数为了保存一个数字所有添加小数点的字符串情况char ** getPos(const char *s, int *returnSize) &#123;    int len = strlen(s);    char **res = (char **)malloc(sizeof(char *) * len);    int pos = 0;    if (s[0] != &#39;0&#39; || strcmp(s, &quot;0&quot;) == 0) &#123;        res[pos] = (char *)malloc(sizeof(char) * (len + 1));        strcpy(res[pos], s);        pos++;    &#125;    for (int p = 1; p &lt; len; ++p) &#123;        if ((p != 1 &amp;&amp; s[0] == &#39;0&#39;) || s[len - 1] == &#39;0&#39;) &#123;            continue;        &#125;        res[pos] = (char *)malloc(sizeof(char) * (len + 2));        strncpy(res[pos], s, p);        sprintf(res[pos] + p, &quot;.%s&quot;, s + p);        pos++;    &#125;    *returnSize = pos;    return res;&#125;char ** ambiguousCoordinates(char * s, int* returnSize) &#123;    int n = strlen(s) - 2;    s = s + 1;    s[n] = &#39;\0&#39;;    char **res = (char *)malloc(sizeof(char *) * pow(n, 3));    int pos = 0;    for (int l = 1; l &lt; n; ++l) &#123;        char ls[n + 1];        strncpy(ls, s, l);        ls[l] = &#39;\0&#39;;        int ltSize = 0;        // x 坐标        char **lt = getPos(ls, &amp;ltSize);        if (ltSize == 0) &#123;            continue;        &#125;        char rs[n + 1];        strncpy(rs, s + l, n - l);        rs[n - l] = &#39;\0&#39;;        int rtSize = 0;        // y 坐标        char **rt = getPos(rs, &amp;rtSize);        if (rtSize == 0) &#123;            continue;        &#125;        // 进行合并        for (int i = 0; i &lt; ltSize; i++) &#123;            for (int j = 0; j &lt; rtSize; j++) &#123;                res[pos] = (char *)malloc(sizeof(char) * (n + 8));                sprintf(res[pos++], &quot;(%s, %s)&quot;, lt[i], rt[j]);            &#125;        &#125;        // 释放空间        for (int i = 0; i &lt; ltSize; i++) &#123;            free(lt[i]);        &#125;        for (int i = 0; i &lt; rtSize; i++) &#123;            free(rt[i]);        &#125;        free(lt);        free(rt);    &#125;    *returnSize = pos;    return res;&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n^3)</code>。其中 <code>n</code> 为题目给定字符串 <code>s</code> 的长度。</li><li>空间复杂度：<code>O (N^3)</code>。其中 <code>n</code> 为题目给定字符串 <code>s</code> 的长度，主要为存储答案所需要的空间开销。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长度为 K 子数组中的最大和</title>
      <link href="/2022/11/06/%E7%AE%97%E6%B3%95%E9%A2%98/%E9%95%BF%E5%BA%A6%E4%B8%BA-K-%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
      <url>/2022/11/06/%E7%AE%97%E6%B3%95%E9%A2%98/%E9%95%BF%E5%BA%A6%E4%B8%BA-K-%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。请你从 <code>nums</code> 中满足下述条件的全部子数组中找出最大子数组和：</p><p>子数组的长度是 <code>k</code>，且<br>子数组中的所有元素 各不相同 。<br>返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回 <code>0</code> 。</p><p>子数组 是数组中一段连续非空的元素序列。</p><span id="more"></span><p>示例 1：</p><pre><code>输入：nums = [1,5,4,2,9,9,9], k = 3输出：15解释：nums 中长度为 3 的子数组是：- [1,5,4] 满足全部条件，和为 10 。- [5,4,2] 满足全部条件，和为 11 。- [4,2,9] 满足全部条件，和为 15 。- [2,9,9] 不满足全部条件，因为元素 9 出现重复。- [9,9,9] 不满足全部条件，因为元素 9 出现重复。因为 15 是满足全部条件的所有子数组中的最大子数组和，所以返回 15 。</code></pre><p>示例 2：</p><pre><code>输入：nums = [4,4,4], k = 3输出：0解释：nums 中长度为 3 的子数组是：- [4,4,4] 不满足全部条件，因为元素 4 出现重复。因为不存在满足全部条件的子数组，所以返回 0 。`</code></pre><p>提示：</p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="思路：前缀和-滑动窗口-哈希表"><a href="#思路：前缀和-滑动窗口-哈希表" class="headerlink" title="思路：前缀和 + 滑动窗口 + 哈希表"></a>思路：前缀和 + 滑动窗口 + 哈希表</h2><ul><li><p>前缀和 ：用一个保存前缀和数组，然后利用 相减 来求出子数组的和。</p></li><li><p>滑动窗口 ：使用一个长度为k的窗口来模拟一个子数组。<br><img src="/./%E5%9B%BE%E5%BA%93/%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C.png"></p></li><li><p>哈希表 ：使用哈希表来判断窗口里面是否有重复元素。</p></li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>#define max(a,b) ((a) &gt; (b)) ? (a) : (b)long long maximumSubarraySum(int* nums, int numsSize, int k)&#123;    long long max = 0,sum[numsSize + 1];    int hash[100001] = &#123;0&#125;;    int i,count = 0;    sum[0] = 0;    // 求出前缀和数组    for (i = 0; i &lt; numsSize ; i++)        sum[i + 1] = sum [i] + nums[i];    for (i = 0; i &lt; numsSize; i++)&#123;        //count 用来记录子数组中重复元素的个数        if (++ hash[nums[i]] &gt; 1)&#123;            count ++;        &#125;        if (i &gt; k - 1 &amp;&amp; --hash[nums[i - k]] &gt; 0)&#123;            count --;        &#125;        // 若子数组中不存在重复元素，则求出其和，判断大小        if (i &gt; k - 2 &amp;&amp; count == 0)&#123;            max = max(max,sum[i + 1] - sum[i - k + 1]);        &#125;    &#125;    return max;&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。数组长度 numsSize </li><li>空间复杂度：<code>O (n)</code>。哈希表以及前缀和数组长度。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hash表 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解析布尔表达式</title>
      <link href="/2022/11/05/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E6%9E%90%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/11/05/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E6%9E%90%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>给你一个以字符串形式表述的 布尔表达式（boolean） <code>expression</code>，返回该式的运算结果。</p><span id="more"></span><p>有效的表达式需遵循以下约定：</p><ul><li><code>&quot;t&quot;</code>，运算结果为 <code>True</code></li><li><code>&quot;f&quot;</code>，运算结果为 <code>False</code></li><li><code>&quot;!(expr)&quot;</code>，运算过程为对内部表达式 <code>expr</code> 进行逻辑 非的运算（NOT）</li><li><code>&quot;&amp;(expr1,expr2,...)&quot;</code>，运算过程为对 <code>2</code> 个或以上内部表达式 <code>expr1, expr2, ...</code> 进行逻辑 与的运算（AND）</li><li><code>&quot;|(expr1,expr2,...)&quot;</code>，运算过程为对 <code>2</code> 个或以上内部表达式 <code>expr1, expr2, ...</code> 进行逻辑 或的运算（OR）</li></ul><p>示例 1：</p><pre><code>输入：expression = &quot;!(f)&quot;输出：true</code></pre><p>示例 2：</p><pre><code>输入：expression = &quot;|(f,t)&quot;输出：true</code></pre><p>示例 3：</p><pre><code>输入：expression = &quot;&amp;(t,f)&quot;输出：false</code></pre><p>示例 4：</p><pre><code>输入：expression = &quot;|(&amp;(t,f,t),!(t))&quot;输出：false</code></pre><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>利用栈，将每一个左右括号进行匹配，即可求出答案。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>bool parseBoolExpr(char * expression)&#123;    int len = strlen(expression);    char stack[len];    int top = 0;    for (int i = 0;i &lt; len;i++)&#123;        if (expression[i] == &#39;,&#39;)            continue;        if (expression[i] != &#39;)&#39;)            stack[top++] = expression[i];        else&#123;            int f = 0, t = 0;            while (stack[top - 1] != &#39;(&#39;)&#123;                char c = stack[--top];                if (c == &#39;f&#39;)                    f++;                if (c == &#39;t&#39;)                    t++;            &#125;            char val = stack[top - 2];            top -= 2;            switch (val)&#123;                case &#39;!&#39;:&#123;                    stack[top++] = t == 1 ? &#39;f&#39; : &#39;t&#39;;                    break;                &#125;                case &#39;&amp;&#39;:&#123;                    stack[top++] = f &gt; 0 ? &#39;f&#39; : &#39;t&#39;;                    break;                &#125;                case &#39;|&#39;:&#123;                    stack[top++] = t &gt; 0 ? &#39;t&#39; : &#39;f&#39;;                    break;                &#125;                default:                    break;            &#125;          &#125;    &#125;    return stack[0] == &#39;t&#39;;&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。表达式的长度。</li><li>空间复杂度：<code>O (n)</code>。栈的容量。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>根据身高重建队列</title>
      <link href="/2022/11/02/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/"/>
      <url>/2022/11/02/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 正好 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p><p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p><span id="more"></span><p>示例 1：</p><pre><code>输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]解释：</code></pre><p>示例 2：</p><pre><code>输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</code></pre><h2 id="思路：先排好高的人再排低的"><a href="#思路：先排好高的人再排低的" class="headerlink" title="思路：先排好高的人再排低的"></a>思路：先排好高的人再排低的</h2><p>这个思路意思大概就是，我人高，看不见比我矮的人，比我矮的都可以无视。</p><p>所以首先，把数组 <code>people</code> 按身高进行排序，（[7,0] 得排在 [7,1] 前面）。</p><p>然后就只需要看 <code>ki</code> 的值，它的值为多少就排在第几。</p><p>比如 <code>[[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</code> 这五的人需要排队。</p><p>我们先按高矮将他们排一次。</p><p>排成了这样 <code>[[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]</code></p><p>然后只需要看 <code>ki</code> 值，他的值为多少，我们就插入至哪个位置。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>int cmp(const void* _a, const void* _b) &#123;    int *a = *(int**)_a, *b = *(int**)_b;    return a[0] == b[0] ? a[1] - b[1] : b[0] - a[0];&#125;int** reconstructQueue(int** people, int peopleSize, int* peopleColSize, int* returnSize, int** returnColumnSizes) &#123;    //将数组 people 按高矮进行排序。    qsort(people, peopleSize, sizeof(int*), cmp);    int** ans = malloc(sizeof(int*) * peopleSize);    *returnSize = 0;    *returnColumnSizes = malloc(sizeof(int) * peopleSize);    for (int i = 0; i &lt; peopleSize; i++) &#123;        (*returnColumnSizes)[i] = 2;    &#125;    //现在开始插队    for (int i = 0; i &lt; peopleSize; ++i) &#123;        int* person = people[i];        (*returnSize)++;        // 将 ki 位置腾出来，让该学生插入。        for (int j = (*returnSize) - 1; j &gt; person[1]; j--) &#123;            ans[j] = ans[j - 1];        &#125;        int* temp = malloc(sizeof(int) * 2);        // temp 用来保存 该学生的数据。        temp[0] = person[0], temp[1] = person[1];        // 插入队伍        ans[person[1]] = temp;    &#125;    return ans;&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(n^2)</code>。</li><li>空间复杂度：<code>O(n)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分割回文串</title>
      <link href="/2022/11/01/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
      <url>/2022/11/01/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 回文串 。返回 <code>s</code> 所有可能的分割方案。</p><p>回文串 是正着读和反着读都一样的字符串。</p><span id="more"></span><p> </p><p>示例 1：</p><pre><code>输入：s = &quot;aab&quot;输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;a&quot;输出：[[&quot;a&quot;]]</code></pre><h2 id="思路一：回溯-动态规划预处理"><a href="#思路一：回溯-动态规划预处理" class="headerlink" title="思路一：回溯 + 动态规划预处理"></a>思路一：回溯 + 动态规划预处理</h2><ul><li>动态规划：</li></ul><p>使用二维数组 <code>f[i][j]</code> 表示 从字符串 <code>s</code> 中的第 <code>i</code> 到第 <code>j</code> 的位置是否 为回文串，若是，则为 <code>1</code> ，不是则为 <code>0</code> 。</p><ul><li>回溯：</li></ul><p>现在已经保存了一个二维数组，我们可以从 <code>i</code> 开始，从小到大依次枚举 <code>j</code>。对于当前枚举的 <code>j</code> 值，我们查看 <code>f[i][j]</code> 的值 <code>s[i..j]</code> 是否为回文串：如果 <code>s[i..j]</code> 是回文串，那么就将其加入答案数组 <code>ans</code> 中，并以 <code>j+1</code> 作为新的 <code>i</code> 进行下一层搜索，并在未来的回溯时将 <code>s[i..j]</code> 从 <code>ans</code> 中移除。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>//深度优先搜索void DFS(char* s, int n, int i, int** f, char*** ret, int* retSize, int* retColSize, char** ans, int* ansSize) &#123;    //若将整个字符串分段存放至 ans 中，则输入进 ret 中。    if (i == n) &#123;        char** tmp = malloc(sizeof(char*) * (*ansSize));        for (int j = 0; j &lt; (*ansSize); j++) &#123;            int ansColSize = strlen(ans[j]);            tmp[j] = malloc(sizeof(char) * (ansColSize + 1));            strcpy(tmp[j], ans[j]);        &#125;        ret[*retSize] = tmp;        retColSize[(*retSize)++] = *ansSize;        return;    &#125;    //深度优先    for (int j = i; j &lt; n; ++j) &#123;        if (f[i][j]) &#123;            char* sub = malloc(sizeof(char) * (j - i + 2));            for (int k = i; k &lt;= j; k++) &#123;                sub[k - i] = s[k];            &#125;            sub[j - i + 1] = &#39;\0&#39;;            ans[(*ansSize)++] = sub;            DFS(s, n, j + 1, f, ret, retSize, retColSize, ans, ansSize);            --(*ansSize);        &#125;    &#125;&#125;// ret[i][j][k]// returnSize 即是 i 的最大值// returnColumnSizes[i] 即是每个 i 对应的 j 的最大值char*** partition(char* s, int* returnSize, int** returnColumnSizes) &#123;    int n = strlen(s);    int retMaxLen = n * (1 &lt;&lt; n);    char*** ret = malloc(sizeof(char**) * retMaxLen);    *returnSize = 0;    *returnColumnSizes = malloc(sizeof(int) * retMaxLen);    // 创建保存 回文串 位置的数组。    int* f[n];    for (int i = 0; i &lt; n; i++) &#123;        f[i] = malloc(sizeof(int) * n);        for (int j = 0; j &lt; n; j++) &#123;            f[i][j] = 1;        &#125;    &#125;    for (int i = n - 1; i &gt;= 0; --i) &#123;        for (int j = i + 1; j &lt; n; ++j) &#123;            f[i][j] = (s[i] == s[j]) &amp;&amp; f[i + 1][j - 1];        &#125;    &#125;    char* ans[n];    int ansSize = 0;    dfs(s, n, 0, f, ret, returnSize, *returnColumnSizes, ans, &amp;ansSize);    return ret;&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n* 2^n)</code>。</li><li>空间复杂度：<code>O (n^2)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 回溯 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神奇字符串</title>
      <link href="/2022/10/31/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%A5%9E%E5%A5%87%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2022/10/31/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%A5%9E%E5%A5%87%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>神奇字符串 <code>s</code> 仅由 <code>&#39;1&#39;</code> 和 <code>&#39;2&#39;</code> 组成，并需要遵守下面的规则：</p><p>神奇字符串 <code>s</code> 的神奇之处在于，串联字符串中 <code>&#39;1&#39;</code> 和 <code>&#39;2&#39;</code> 的连续出现次数可以生成该字符串。<br><code>s</code> 的前几个元素是 <code>s = &quot;1221121221221121122……&quot;</code> 。如果将 <code>s</code> 中连续的若干 <code>1</code> 和 <code>2</code> 进行分组，可以得到 <code>&quot;1 22 11 2 1 22 1 22 11 2 11 22 ......&quot;</code> 。每组中 <code>1</code> 或者 <code>2</code> 的出现次数分别是 <code>&quot;1 2 2 1 1 2 1 2 2 1 2 2 ......&quot;</code> 。上面的出现次数正是 <code>s</code> 自身。</p><p>给你一个整数 <code>n</code> ，返回在神奇字符串 <code>s</code> 的前 <code>n</code> 个数字中 <code>1</code> 的数目。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre><code>输入：n = 6输出：3解释：神奇字符串 s 的前 6 个元素是 “122112”，它包含三个 1，因此返回 3 。 </code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 1输出：1</code></pre><h2 id="思路：双指针"><a href="#思路：双指针" class="headerlink" title="思路：双指针"></a>思路：双指针</h2><p>利用双指针，第一个指针用来遍历整个字符串。<br>第二个指针用来决定第一个指针所指位置的值。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>int magicalString(int n)&#123;    char *s = (char*)malloc (n+1);    int num = 0,flag = 1,changFlag = 1;    //双指针分别是 i 和 pos 。    for (int i = 0,pos = 0;i &lt; n;i++)&#123;        s[i] = flag + &#39;0&#39;;        num += s[i] - &#39;0&#39;;        // changFlag 用来判断 flag 是否需要变值        if (changFlag != s[pos] - &#39;0&#39;)&#123;            changFlag ++;        &#125;else &#123;            changFlag = 1;            pos++;            // 转变数字             flag ^= 3;        &#125;    &#125;    return 2 * n - num;&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。遍历了整个字符串一遍。</li><li>空间复杂度：<code>O (n)</code>。需要构造长度为 n 的字符串。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字母大小写全排列</title>
      <link href="/2022/10/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/2022/10/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串 <code>s</code> ，通过将字符串 <code>s</code> 中的每个字母转变大小写，我们可以获得一个新的字符串。</p><p>返回所有可能得到的字符串集合 。以<strong>任意顺序</strong>返回输出。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;a1b2&quot;输出：[&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: s = &quot;3z4&quot;输出: [&quot;3z4&quot;,&quot;3Z4&quot;]</code></pre><p><strong>提示：</strong></p><ul><li><code>s</code> 的长度不超过12.</li><li><code>s</code> 由小写英文字母、大写英文字母和数字组成</li></ul><h2 id="思路一：广度优先搜索"><a href="#思路一：广度优先搜索" class="headerlink" title="思路一：广度优先搜索"></a>思路一：广度优先搜索</h2><p>从左往右遍历字符串，当我们遍历下一个字符 <code>c</code> 时：</p><ul><li>如果 <code>c</code> 为一个数字，则队列中所有的序列的末尾均加上 <code>c</code> ，将修改后的序列再次进入到队列中；</li><li>如果 <code>c</code> 为一个字母，此时我们在上述序列的末尾依次分别加上 <code>c</code> 的小写形式 <code>lowercase(c)</code> 和 <code>c</code> 的大写形式 <code>uppercase(c)</code> 后，再次将上述数列放入队列；</li><li>如果队列中当前序列的长度等于 <code>s</code> 的长度，则表示当前序列已经搜索完成，该序列为全排列中的一个合法序列；</li></ul><p>由于每个字符的大小写形式刚好差了 32，因此在大小写转换时可以用 C⊕32 来进行转换。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>//链表队列的结构体typedef struct node&#123;    char str[16];    struct node *next;&#125;Node;//建立一个 节点Node * creatNode(char * str)&#123;    Node * node = (Node*)malloc (sizeof(Node));    memset(node,0,16);    strcpy(node-&gt;str,str);    node-&gt;next = NULL;    return node;&#125;//返回函数char ** letterCasePermutation(char * s, int* returnSize)&#123;    int n = strlen (s);    char **ans = (char**)malloc(sizeof(char*)* (1 &lt;&lt; n));// &lt;&lt; 是位运算符，左移    int pos = 0;    //现在创建个链表队列    Node *head = NULL,*tail = NULL;    head = tail = creatNode(&quot;&quot;);    while(head)&#123;        char *curr = head-&gt;str;        int len = strlen(curr);        if(len == n)&#123;            //若已经遍历完成，则将队列头字符串加入至ans中            ans[pos] = (char*)malloc(sizeof(char)*16);            strcpy(ans[pos++],head);            head = head-&gt;next;        &#125;else&#123;            //若s[len]是字母则向队列中加入            if(isalpha(s[len]))&#123;                tail-&gt;next = creatNode(curr);                tail = tail-&gt;next;                tail-&gt;str[len] = s[len] ^ 32;// ^ 是位运算符，异或            &#125;            curr[len] = s[len];        &#125;    &#125;    *returnSize = pos;    return ans;&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li><p>时间复杂度：<code>O (n * 2^n)</code>。 其中 n 表示字符串的长度。全排列的数目最多为 2^n 个，每次生成一个新的序列的时间为 O(n)，因此时间复杂度为 O(n * 2^n) 。</p></li><li><p>空间复杂度：<code>O (n * 2^n)</code>。其中 n 表示字符串的长度。队列中的元素数目最多为 2^n 个，每个序列需要的空间为为 O(n)，因此空间复杂度为 O(n * 2^n) 。</p></li></ul><h2 id="思路二：回溯"><a href="#思路二：回溯" class="headerlink" title="思路二：回溯"></a>思路二：回溯</h2><p>同样的思路我们还可以采用回溯的思想，从左往右依次遍历字符，当在进行搜索时，搜索到字符串 s 的第 i 个字符时：</p><ul><li>如果 c 为一个数字，则我们继续检测下一个字符；</li><li>如果 c 为一个字母，我们将字符中的第 i 个字符 c 改变大小写形式后，往后继续搜索，完成改写形式的子状态搜索后，我们将 c 进行恢复，继续往后搜索；</li><li>如果当前完成字符串搜索后，则表示当前的子状态已经搜索完成，该序列为全排列中的一个；</li></ul><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><pre><code>void dfs(char *s, int pos, char **res,int* returnSize) &#123;    //当 c 为数字时跳过。    while (isdigit(s[pos]) &amp;&amp; s[pos++] != &#39;\0&#39;);    //当遍历完字符串时。将字符串 s 放入 res 中。    if (s[pos] == &#39;\0&#39;) &#123;        res[*returnSize] = (char *)malloc(sizeof(char) * (strlen(s) + 1));        strcpy(res[*returnSize], s);        (*returnSize)++;        return;    &#125;    //若这个位置是字母，则将字母的大小写分别写进2个函数。    //开始递归。    s[pos] ^= 32;    dfs(s, pos + 1, res, returnSize);    s[pos] ^= 32;    dfs(s, pos + 1, res, returnSize);&#125;//返回函数char ** letterCasePermutation(char * s, int* returnSize) &#123;    int n = strlen(s);    *returnSize = 0;    char **ans = (char **)malloc(sizeof(char *) * (1 &lt;&lt; n));    dfs(s, 0, ans, returnSize);    return ans;&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li><p>时间复杂度：<code>O (n * 2^n)</code>。 其中 n 表示字符串的长度。递归深度最多为 n，所有可能的递归子状态最多为 2^n 个，每次个子状态的搜索时间为 O(n)，因此时间复杂度为 O(n * 2^n) 。</p></li><li><p>空间复杂度：<code>O (1)</code>。除返回值以外不需要额外的空间 。</p></li></ul><h2 id="思路三：-二进制位图"><a href="#思路三：-二进制位图" class="headerlink" title="思路三： 二进制位图"></a>思路三： 二进制位图</h2><p>假设字符串 s 有 m 个字母，那么全排列就有 2^m 个字符串序列，且可以用位掩码 bits 唯一地表示一个字符串。</p><ul><li>bits 的第 i 位为 0 表示字符串 s 中从左往右第 i 个字母为小写形式</li><li>bits 的第 i 位为 1 表示字符串 s 中从左往右第 i 个字母为大写形式</li></ul><p>我们采用的位掩码只计算字符串 s 中的字母，对于数字则直接跳过，通过位图计算从而构造正确的全排列。我们依次检测字符串第 i 个字符串 c：</p><ul><li><p>如果字符串 c 为数字，则我们直接在当前的序列中添加字符 c；</p></li><li><p>如果字符串 c 为字母，且 c 为字符串中的第 k 个字母，如果掩码 bits 中的第 k 位为 0，则添加字符串 c 的小写形式；如果掩码 bits 中的第 k 位为 1，则添加字符串 c 的大写形式；</p></li></ul><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><pre><code>char ** letterCasePermutation(char * s, int* returnSize)&#123;    int n = strlen(s);    int m = 0;    for (int i = 0; i &lt; n; i++) &#123;        if (isalpha(s[i])) &#123;            m++;        &#125;    &#125;    char **ans = (char **)malloc(sizeof(char *) * (1 &lt;&lt; m));    for (int mask = 0; mask &lt; (1 &lt;&lt; m); mask++) &#123;        //mask即是 二进制位图        //现在是将 2^m 个字符串依次按照位图信息存入ans中。        ans[mask] = (char *)malloc(sizeof(char) * (n + 1));        ans[mask][n] = &#39;\0&#39;;        for (int j = 0, k = 0; j &lt; n; j++) &#123;             if (isalpha(s[j]) &amp;&amp; (mask &amp; (1 &lt;&lt; k++))) &#123;                //若是字母，且位图 mask 中的第 j 位为 1 则添加大字母。                ans[mask][j] = toupper(s[j]);            &#125; else &#123;                //第 j 位是数字则直接添加 c                 ans[mask][j] = tolower(s[j]);            &#125;        &#125;    &#125;    *returnSize = (1 &lt;&lt; m);    return ans;&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li><p>时间复杂度：<code>O (n * 2^n)</code>。 其中 n 表示字符串的长度。最多有 2^n 个序列，每次生成一个新的序列的时间为 O(n)，因此时间复杂度为 O(n * 2^n) 。</p></li><li><p>空间复杂度：<code>O (1)</code>。除返回值以外不需要额外的空间 。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
            <tag> 位图 </tag>
            
            <tag> 广度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转链表</title>
      <link href="/2022/10/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/10/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><span id="more"></span><p>示例 1：</p><pre><code>输入：head = [1,2,3,4,5]输出：[5,4,3,2,1]</code></pre><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>新建一个链表头。让目标链表依次指向链表头。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>Definition for singly-linked list.struct ListNode &#123;    int val;    struct ListNode *next;&#125;;struct ListNode* reverseList(struct ListNode* head)&#123;    //新链表头    struct ListNode *newListHead = NULL;    struct ListNode *tempNode = NULL;    while(head)&#123;        //储存当前链表的下一个节点的地址        tempNode = head-&gt;next;        //当前链表的当前节点指向新链表头        head-&gt;next = newListHead;        //因为新链表头有变化，更新 新链表头。        newListHead = head;        //接着处理当前链表的下一个节点        head = tempNode;    &#125;    return newListHead;&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。遍历整个链表。</li><li>空间复杂度：<code>O (1)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2022/10/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/10/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>链表（List）是是一种线性表数据结构。它用不连续的内存空间，来存储一组具有相同类型的数据。</p><span id="more"></span><h2 id="链表的优缺点："><a href="#链表的优缺点：" class="headerlink" title="链表的优缺点："></a>链表的优缺点：</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>是一种动态数据结构。</li><li>易于插入和删除。</li><li>内存利用率高。</li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>储存密度低，比较浪费内存，因为储存元素时，需要额外存储指针。</li><li>不支持随机访问。</li><li>查找元素效率低。</li></ul><h2 id="理解指针或引用的含义"><a href="#理解指针或引用的含义" class="headerlink" title="理解指针或引用的含义"></a>理解指针或引用的含义</h2><p>要学好链表，首先得学好指针。</p><p>指针的理解：</p><p>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</p><p>简单的来说就是：</p><pre><code>int *p = data;//则有以下两条：*p == data;p == &amp;data;</code></pre><h2 id="链表的种类："><a href="#链表的种类：" class="headerlink" title="链表的种类："></a>链表的种类：</h2><ul><li><p>单向链表</p><p>  结构代码：</p></li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct <span class="keyword">node</span><span class="title">&#123;</span></span><br><span class="line"><span class="title">    int</span> value;</span><br><span class="line">    struct <span class="keyword">node</span> <span class="title">*next</span>;</span><br><span class="line">&#125;singlyLinkList;</span><br></pre></td></tr></table></figure><ul><li><p>双向链表</p><p>  结构代码：</p></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> struct <span class="built_in">double</span>Node&#123;</span><br><span class="line">    <span class="built_in">int</span> value;</span><br><span class="line">    struct <span class="built_in">double</span>Node *prior;</span><br><span class="line">    struct <span class="built_in">double</span>Node *next;</span><br><span class="line">&#125;<span class="built_in">double</span>LinkList;</span><br></pre></td></tr></table></figure><ul><li>循环链表</li></ul><p>循环链表的结构代码和前面两个一样，就是把尾节点和首节点连起来了。</p><h2 id="数据的查找、插入和删除"><a href="#数据的查找、插入和删除" class="headerlink" title="数据的查找、插入和删除"></a>数据的查找、插入和删除</h2><h3 id="查找："><a href="#查找：" class="headerlink" title="查找："></a>查找：</h3><p>查找只能遍历整个链表。时间复杂度 O(n)。</p><h3 id="插入："><a href="#插入：" class="headerlink" title="插入："></a>插入：</h3><p>插入节点为 p2 ，将插入在 p1 之后。</p><p>代码实现：</p><pre><code>p2-&gt;next = p1-&gt;next;p1-&gt;next = p2;</code></pre><p>时间复杂度为 O(1) 。</p><h3 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h3><p>只需将该节点的上一个节点的 next 值指向这个节点的 next 即完成节点的删除。</p><p>代码实现：</p><pre><code>p-&gt;next = p-&gt;next-&gt;next;</code></pre><p>这样就将p的下一个节点删除了（还要将删除的空间给 free 掉）。</p><p>时间复杂度为 O(1) 。</p><h2 id="边界问题（设置哨兵）"><a href="#边界问题（设置哨兵）" class="headerlink" title="边界问题（设置哨兵）"></a>边界问题（设置哨兵）</h2><p>在插入删除头节点这个边界问题时，和其他节点时的代码不一样，那就需要使用不同的代码进行描述。</p><p>为了解决这种问题，我们可以在单链表的第一个节点之前设置个节点（一般称为哨兵节点），不保存数据只指向链表的第一个节点，这样，所有的操作都可以用相同的代码进行实现。</p><h2 id="链表的各种实现"><a href="#链表的各种实现" class="headerlink" title="链表的各种实现"></a>链表的各种实现</h2><h3 id="定义结构体："><a href="#定义结构体：" class="headerlink" title="定义结构体："></a>定义结构体：</h3><pre><code>typedef struct list&#123;    int data;    struct list *next;&#125;List;</code></pre><h3 id="申请一个节点"><a href="#申请一个节点" class="headerlink" title="申请一个节点:"></a>申请一个节点:</h3><pre><code>&#123;    List* node = (List*)malloc (sizeof(List));    node-&gt;data = x;    node-&gt;next = NULL;&#125;</code></pre><h3 id="链表头插："><a href="#链表头插：" class="headerlink" title="链表头插："></a>链表头插：</h3><pre><code>//对于头节点不保存元素的链表：&#123;    head-&gt;next = node;&#125;//对于头节点要保存元素的链表：&#123;    node-&gt;next = head;    head = node;&#125;</code></pre><h3 id="链表尾插："><a href="#链表尾插：" class="headerlink" title="链表尾插："></a>链表尾插：</h3><pre><code>&#123;    List* Head = head;    //遍历至链尾    while(Head-&gt;next != NULL)&#123;        Head = Head-&gt;next;    &#125;    Head-&gt;next = node;&#125;</code></pre><h3 id="链表头删："><a href="#链表头删：" class="headerlink" title="链表头删："></a>链表头删：</h3><pre><code>//对于头节点不保存元素的链表：&#123;    List* node = head-&gt;next;    head-&gt;next = node-&gt;next;    free(node);&#125;//对于头节点要保存元素的链表：&#123;    List* node = head;    head = head-&gt;next;    free(node);&#125;</code></pre><h3 id="链表尾删："><a href="#链表尾删：" class="headerlink" title="链表尾删："></a>链表尾删：</h3><pre><code>&#123;    List* Head = head;    //遍历至链尾    while(Head-&gt;next != NULL)&#123;        Head = Head-&gt;next;    &#125;    Head = NULL;&#125;</code></pre><h3 id="寻找节点："><a href="#寻找节点：" class="headerlink" title="寻找节点："></a>寻找节点：</h3><pre><code>//要寻找的节点值为 x ;&#123;    List* node = NULL;    List* Head = head;    while (Head-&gt;next != NULL)&#123;        if (Head-&gt;data == x)&#123;            node = Head;            break;        &#125;        Head = Head-&gt;next;    &#125;    return node;&#125;</code></pre><h3 id="在指定节点值-x-前插入节点："><a href="#在指定节点值-x-前插入节点：" class="headerlink" title="在指定节点值 x 前插入节点："></a>在指定节点值 x 前插入节点：</h3><pre><code>//要插入的节点为 node;&#123;    List* Head = head;    while (Head-&gt;next != NULL)&#123;        if (Head-&gt;next-&gt;data == x)&#123;            node-&gt;next = Head-&gt;next;            Head-&gt;next = node;            break;        &#125;        Head = Head-&gt;next;    &#125;&#125;</code></pre><h3 id="删除指定节点值-x-的前节点："><a href="#删除指定节点值-x-的前节点：" class="headerlink" title="删除指定节点值 x 的前节点："></a>删除指定节点值 x 的前节点：</h3><pre><code>&#123;    List* frontNode = head;    List* node = frontNode-&gt;next;    while (node-&gt;next != NULL)&#123;        if (node-&gt;next-&gt;data == x)&#123;            frontNode-&gt;next = node-&gt;next;            free(node);            break;        &#125;        frontNode = node;        node = frontNode-&gt;next;    &#125;&#125;</code></pre><h3 id="寻找倒数第-k-个节点："><a href="#寻找倒数第-k-个节点：" class="headerlink" title="寻找倒数第 k 个节点："></a>寻找倒数第 k 个节点：</h3><pre><code>&#123;    List* ansNode = head;    List* node = head;    //用双指针，一个指针先跑 k 个节点，答案节点再与其一起跑    for (int i = 0;i &lt; k;i++)&#123;        node = node-&gt;next;    &#125;    while (node != NULL)&#123;        node = node-&gt;next;        ansNode =ansNode-&gt;next;    &#125;    return ansNode;&#125;</code></pre><h3 id="链表的释放："><a href="#链表的释放：" class="headerlink" title="链表的释放："></a>链表的释放：</h3><pre><code>&#123;    List* node = head;    while (head != NULL)&#123;        head = head-&gt;next;        free(node);        node = head;    &#125;&#125;</code></pre><hr><p><a href="http://caoxing.run/tags/%E9%93%BE%E8%A1%A8/">关于链表的一些练习</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2022/10/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/"/>
      <url>/2022/10/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p><span id="more"></span><h2 id="数组的优缺点："><a href="#数组的优缺点：" class="headerlink" title="数组的优缺点："></a>数组的优缺点：</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>按照索引查询元素速度快</li><li>能存储大量数据</li><li>按照索引遍历数组方便</li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>根据内容查找元素速度慢</li><li>数组的大小一经确定不能改变。</li><li>数组只能存储一种类型的数据</li><li>增加、删除元素效率慢</li><li>未封装任何方法，所有操作都需要用户自己定义。</li></ul><h2 id="数组如何实现随机访问？"><a href="#数组如何实现随机访问？" class="headerlink" title="数组如何实现随机访问？"></a>数组如何实现随机访问？</h2><p>主要取决于数组的特性：</p><ul><li>是一种线性表（Linear List）。</li><li>连续的内存空间和相同类型的数据。</li></ul><p>计算机需要访问某个元素时，需要通过下面的寻址公式，来计算出元素的内存地址以达到随机访问的目的：</p><pre><code>a[i]_address  = base_address + i * data_type_size</code></pre><h2 id="数组下标为什么不从-1-开始？"><a href="#数组下标为什么不从-1-开始？" class="headerlink" title="数组下标为什么不从 1 开始？"></a>数组下标为什么不从 1 开始？</h2><p>从数组的内存模型上看，数组”下标”最确切的定义是”偏移（offset）”。一般编程时，都是以 a 来表示数组的首地址，a[0] 就是偏移为 0 个位置。a[k] 则表示偏移 k 个 type_size 的位置。</p><p>所以计算 a[k] 的内存地址就要用到这个公式：</p><pre><code>a[k]_address  = base_address + k * data_type_size</code></pre><p>若以 1 为下标开始的话 a[k] 内存地址就变为：</p><pre><code>a[k]_address  = base_address + (k - 1) * data_type_size</code></pre><p>这样每次访问数组元素时都多了一次减法，对于 CPU 来说，就是相当于多了一次减法指令。数组又作为一个非常基础的数据结构，通过下标随机访问数组元素又是非常常见的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次指令操作，数组就选择以 0 开始编号，而不是 1 开始。</p><p>当然这也不是很绝对，也是有很多语言并不是从 0 开始计数的，例如 Matlab 。甚至还有一些语言支持负数下标，例如 Python 。 </p><h2 id="数组的查找、插入和删除。"><a href="#数组的查找、插入和删除。" class="headerlink" title="数组的查找、插入和删除。"></a>数组的查找、插入和删除。</h2><h3 id="查找："><a href="#查找：" class="headerlink" title="查找："></a>查找：</h3><p>一般 数组的查找的时间复杂度是 O(n) ；</p><p>但对于已经排好序的数组来说，可以利用二分查找，时间复杂度是 O(logn);</p><p>数组是你说根据下标随机访问的时间复杂度为 O(1)。</p><h3 id="插入和删除："><a href="#插入和删除：" class="headerlink" title="插入和删除："></a>插入和删除：</h3><p>因为数组的特性，所以我们插入和删除时也要保证内存数据的连续性。</p><p>这样我们插入和删除两个操作就变得比较的低效。</p><ul><li>最好情况：插入和删除时间复杂度 O(1);（操作数在末尾）</li><li>最坏情况：插入和删除时间复杂度 O(n);（操作数在头部）</li><li>平均情况：插入和删除时间复杂度 O(n)；因为删除每个位置的元素的概率相同，故需要操作次数为（1+2+3+…+n）&#x2F; n &#x3D; (n + 1) &#x2F; 2 ；所以时间复杂度还是 O(n) 。</li></ul><h2 id="警惕数组访问越界的问题。"><a href="#警惕数组访问越界的问题。" class="headerlink" title="警惕数组访问越界的问题。"></a>警惕数组访问越界的问题。</h2><p>数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。</p><p>因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。这种情况下，一般都会出现莫名其妙的逻辑错误。</p><p>而且，很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统，所以写代码的时候一定要警惕数组越界。但并非所有的语言都像 C 一样，把数组越界检查的工作丢给程序员来做，像 Java 和 Python 本身就会做越界检查，若越界java就会抛出 java.lang.ArrayIndexOutOfBoundsExcept。</p><hr><p><a href="http://caoxing.run/tags/%E6%95%B0%E7%BB%84/">关于数组的一些练习</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>下一个更大元素 I</title>
      <link href="/2022/10/28/%E7%AE%97%E6%B3%95%E9%A2%98/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I/"/>
      <url>/2022/10/28/%E7%AE%97%E6%B3%95%E9%A2%98/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I/</url>
      
        <content type="html"><![CDATA[<p><code>nums1</code> 中数字 <code>x</code> 的 下一个更大元素 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 右侧 的 第一个 比 <code>x</code> 大的元素。</p><p>给你两个 没有重复元素 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从<code>0</code> 开始计数，其中 <code>nums1</code> 是 <code>nums2</code> 的子集。</p><p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p><p>返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的 下一个更大元素 。</p><span id="more"></span><p>示例 1：</p><pre><code>输入：nums1 = [4,1,2], nums2 = [1,3,4,2].输出：[-1,3,-1]解释：nums1 中每个值的下一个更大元素如下所述：- 4 ，在nums2 的第三个位子 右边不存在下一个更大元素，所以答案是 -1 。- 1 ，在nums2 的第一个位子 下一个更大元素是 3 。- 2 ，在nums2 的第四个位子 不存在下一个更大元素，所以答案是 -1 。</code></pre><p>示例 2：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="symbol">nums1</span> = [<span class="number">2</span>,<span class="number">4</span>], <span class="symbol">nums2</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">-1</span>]</span><br><span class="line">解释：<span class="symbol">nums1</span> 中每个值的下一个更大元素如下所述：</span><br><span class="line">- <span class="number">2</span> ，在<span class="symbol">nums2</span> 的第二个位子 下一个更大元素是 <span class="number">3</span> 。</span><br><span class="line">- <span class="number">4</span> ，在<span class="symbol">nums2</span> 的第四个位子 不存在下一个更大元素，所以答案是 <span class="number">-1</span> 。</span><br></pre></td></tr></table></figure><h2 id="思路：单调栈-哈希表"><a href="#思路：单调栈-哈希表" class="headerlink" title="思路：单调栈 + 哈希表"></a>思路：单调栈 + 哈希表</h2><p>暴力解题就不搞了 n^2 ，谁都会，现在我们得降低时间复杂度。</p><p>单调栈，听名字就知道，这个栈保存的数据全是单调递增或递减的。</p><p>那怎么做出这种栈呢？即当一个元素想要加入前，与栈顶元素相比，比这个元素小的全部移除。</p><p>我们从后往前遍历 <code>nums2</code> 这个数组，将每个元素加入栈中。(加入时，已经把比元素大的移除了)</p><ul><li>若加入时，这个栈是空的，则说明这个元素在 <code>nums2</code> 数组的右侧没有比他更大的元素。在 哈希表 中记录为 <code>-1</code>；</li><li>若加入时，这个栈不空，则说明这个元素在 <code>nums2</code> 数组的右侧有比他更大的元素。在 哈希表 中记录为栈顶元素的大小；</li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>int* nextGreaterElement(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize)&#123;    *returnSize = nums1Size;    int *ans = malloc (nums1Size*sizeof(int));    int *stack = malloc (nums2Size*sizeof(int));    int top = 0;//定义栈。    int hash[10001];    memset (hash,-1,sizeof(hash));    for (int i = nums2Size - 1;i &gt;= 0;i--)&#123;        //移除栈顶比该元素小的元素。        while (top != 0 &amp;&amp; nums2[i] &gt; stack[top-1])            top--;        if (top != 0)            hash[nums2[i]] = stack[top-1];        //将元素加入栈中。        stack[top++] = nums2[i];    &#125;    for(int i = 0;i &lt; nums1Size;i++)&#123;        ans[i] = hash[nums1[i]];    &#125;    return ans;&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (m * n)</code>。 m,n 分别为 nums1 和 nums2 的长度。</li><li>空间复杂度：<code>O (m + n)</code>。 栈的大小以及哈希表所占空间，因为c语言没有哈希表这个数据结构，所以哈希表的申请空间有点奇怪。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 栈 </tag>
            
            <tag> hash表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子数组的最小值之和</title>
      <link href="/2022/10/28/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C/"/>
      <url>/2022/10/28/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数数组 <code>arr</code>，找到 <code>min(b)</code>  的总和，其中 <code>b</code> 的范围为 <code>arr</code> 的每个（连续）子数组。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = <span class="comment">[3,1,2,4]</span></span><br><span class="line">输出：17</span><br><span class="line">解释：</span><br><span class="line">子数组为 <span class="comment">[3]</span>，<span class="comment">[1]</span>，<span class="comment">[2]</span>，<span class="comment">[4]</span>，<span class="comment">[3,1]</span>，<span class="comment">[1,2]</span>，<span class="comment">[2,4]</span>，<span class="comment">[3,1,2]</span>，<span class="comment">[1,2,4]</span>，<span class="comment">[3,1,2,4]</span>。</span><br><span class="line">最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = <span class="string">[11,81,94,43,3]</span></span><br><span class="line">输出：<span class="number">444</span></span><br></pre></td></tr></table></figure><p>提示：</p><p><code>1 &lt;= arr.length &lt;= 3 * 104</code><br><code>1 &lt;= arr[i] &lt;= 3 * 104</code></p><h2 id="思路一：暴力"><a href="#思路一：暴力" class="headerlink" title="思路一：暴力"></a>思路一：暴力</h2><p>计算出每个子数组的最小值进行相加<br>先计算长度为 1 的保存至数组 SubarrayMin 中，每次增加一个长度，i 即为此时子数组长度。遍历，所有值相加。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="built_in">min</span>(a,b) (a &gt; b ? b : a)</span><br><span class="line"><span class="built_in">int</span> sumSubarrayMins(<span class="built_in">int</span>* arr, <span class="built_in">int</span> arrSize)&#123;</span><br><span class="line">    <span class="built_in">int</span> SubarrayMin[arrSize];</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arrSize;i++)&#123;</span><br><span class="line">        SubarrayMin[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arrSize;i++)&#123;</span><br><span class="line">        for(<span class="built_in">int</span> j = <span class="number">0</span>; i + j &lt; arrSize;j++)&#123;</span><br><span class="line">            SubarrayMin[j] = <span class="built_in">min</span>(SubarrayMin[ j ],arr[j + i]);</span><br><span class="line">            <span class="built_in">sum</span> += SubarrayMin[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n ^ 2)</code>。</li><li>空间复杂度：<code>O (n)</code> 。</li></ul><h2 id="思路二：单调栈"><a href="#思路二：单调栈" class="headerlink" title="思路二：单调栈"></a>思路二：单调栈</h2><p>关于【<a href="">单调栈</a>】可以参考 <a href="./%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I.md">下一个最大元素｜题解</a></p><p>暴力解题的思路就是找到所有的子数组中的最小值，然后进行相加。</p><p>那么我们这就换一种思路，找到数组中的每一个元素可以在多少个子数组中充当最小值。把这个子数组的个数求出，乘以他的值，累加，即可求解。</p><p>我们先看元素 <code>arr[i]</code>，是不是只需要分别找到他的左边第一个比他大的值（下标 <code>i</code> ），和右边第一个比他大的值（下标 <code>j</code>），在下标 <code>[i,j]</code> 之间的子数组，只要 <code>arr[i]</code> 在这里面是不是就是最小的？</p><p>接下来就是找 <code>i</code> 和 <code>j</code> 了：</p><ul><li>创建单调递增栈，先从前往后遍历，将数组元素的下标（x）保存至栈中，在元素进去前，将比他大的元素移除，直到栈中所有元素都不比他大，则此时栈顶元素就是要找的 <code>i</code>,我们将 <code>x - i</code>保存至数组 <code>left[x]</code> 中。</li><li>再将栈重置，从后往前遍历，将数组元素的下标（x）保存至栈中，在元素进去前，，为了避免多算以及少算，将不小于他的元素移除，直到栈中所有元素都小于他，就能找到 <code>j</code> 我们将 <code>j - x</code> 保存至数组 <code>right[x]</code> 中。</li><li>那么下标为 <code>x</code> 的元素所在的子数组就共有 <code>left[x] * right[x]</code> 个。</li></ul><p>个数乘以元素，加入到 sum 中即可。</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumSubarrayMins</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> arrSize)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> left[arrSize],right[arrSize];</span><br><span class="line">    <span class="type">int</span> stack[arrSize],top = <span class="number">0</span>;<span class="comment">//构建单调递减栈，栈中记录数据所在数据的下标</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrSize;i++)&#123;</span><br><span class="line">        <span class="comment">//移除比该元素大的数</span></span><br><span class="line">        <span class="keyword">while</span> (top != <span class="number">0</span> &amp;&amp; arr[i] &lt;= arr[stack[top<span class="number">-1</span>]])</span><br><span class="line">            top--;</span><br><span class="line">        <span class="keyword">if</span> (top != <span class="number">0</span>)</span><br><span class="line">            left[i] = i - stack[top <span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left[i] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//将元素下标加入栈中</span></span><br><span class="line">        stack[top++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    top = <span class="number">0</span>;<span class="comment">//初始化栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = arrSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">while</span> (top != <span class="number">0</span> &amp;&amp; arr[i] &lt; arr[stack[top<span class="number">-1</span>]])</span><br><span class="line">            top--;</span><br><span class="line">        <span class="keyword">if</span> (top != <span class="number">0</span>)</span><br><span class="line">            right[i] = stack[top<span class="number">-1</span>] - i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right[i] = arrSize - i;</span><br><span class="line">        stack[top++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; arrSize;i++ )&#123;</span><br><span class="line">        sum += arr[i] * left[i] * right[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。遍历三次数组</li><li>空间复杂度：<code>O (n)</code>。栈，left 数组，right 数组。</li></ul><h2 id="思路三：动态规划"><a href="#思路三：动态规划" class="headerlink" title="思路三：动态规划"></a>思路三：动态规划</h2><p>上面就是只利用了单调栈来解决问题，其实还可以再用动态规划来解决问题。</p><p>我们要解决 长度为 <code>i</code> 的问题，可以看成 长度为 <code>i-1</code> 数组又加了一个元素在尾端，那么子数组就增加了 i 个，现在就是要求这 i 个数组的最小值之和的问题。那这 i 个数组都是以 arr[i]为最右端的数组，那我们先找到离 <code>arr[i]</code> 最近且比 <code>arr[i]</code> 小的 <code>arr[k]</code>。</p><p>这 <code>i</code> 个数组分成两部分，第一部分是不含 <code>arr[k]</code> 的那部分，第二部分是含 <code>arr[k]</code> 的部分。</p><p>第一部分的最小值之和很容易求，为 <code>i-k * arr[i]</code>。</p><p>第二部分，含 <code>arr[k]</code> 下标那部分单独拎出来看，是不是和 在数组前 <code>k-1</code> 个元素在尾端加入 第 <code>k</code> 个元素的 最小值之和 相等呢？</p><p><img src="/./../../img/topic/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C.png"></p><p>数组数量一样，数组前 <code>k + 1</code> 个元素一样，<code>arr[k+1]~arr[i]</code> 中没有比 <code>arr[k]</code> 最小的数。</p><p>是不是就有以下的动态规划公式？</p><blockquote><p>dp[i] &#x3D; k*arr[i] + dp[i−k];</p></blockquote><p>这个 k 下标寻找的方法和方法二一样，就是利用单调栈。</p><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><pre><code>int sumSubarrayMins(int* arr, int arrSize) &#123;    int ans = 0;    int monoStack[arrSize], dp[arrSize];    int top = 0;    for (int i = 0; i &lt; arrSize; i++) &#123;        while (top &gt; 0 &amp;&amp; arr[monoStack[top - 1]] &gt; arr[i]) &#123;            top--;        &#125;        int k = top == 0 ? (i + 1) : (i - monoStack[top - 1]);        //递推公式        dp[i] = k * arr[i] + (top == 0 ? 0 : dp[i - k]);        //求和        ans += dp[i];        monoStack[top++] = i;    &#125;    return ans;&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。遍历一次数组</li><li>空间复杂度：<code>O (n)</code>。单调栈以及数组 dp。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>和至少为 K 的最短子数组</title>
      <link href="/2022/10/26/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BA-K-%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2022/10/26/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BA-K-%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，找出 <code>nums</code> 中和至少为 <code>k</code> 的 <strong>最短非空子数组</strong> ，并返回该子数组的长度。如果不存在这样的 <strong>子数组</strong> ，返回 <code>-1</code> 。</p><p><strong>子数组</strong> 是数组中 <strong>连续</strong> 的一部分。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [1], k = 1</span></span><br><span class="line"><span class="string">输出：1</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [1,2], k = 4</span></span><br><span class="line"><span class="string">输出：-1</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [2,-1,2], k = 3</span></span><br><span class="line"><span class="string">输出：3</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li><li><code>1 &lt;= k &lt;= 109</code></li></ul><h2 id="思路一：暴力"><a href="#思路一：暴力" class="headerlink" title="思路一：暴力"></a>思路一：暴力</h2><p>暴力解题，没什么好说的，但存在着问题。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> shortestSubarray(<span class="built_in">int</span>* nums, <span class="built_in">int</span> numsSize, <span class="built_in">int</span> k)&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">min</span> = numsSize + <span class="number">1</span>;</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; numsSize;i++)&#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">0</span>,j;</span><br><span class="line">        for(j = i;<span class="built_in">sum</span> &lt; k &amp;&amp; j &lt; numsSize;j++)&#123;</span><br><span class="line">            <span class="built_in">sum</span> += nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sum</span> &gt;= k)&#123;</span><br><span class="line">            <span class="built_in">min</span> = <span class="built_in">min</span> &lt; (j - i) ? <span class="built_in">min</span> : (j - i); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">min</span> == numsSize + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n^2)</code>。在这种时间复杂度下，他的运行时间有可能超时，所以该方法不可取。</li><li>空间复杂度：<code>O (1)</code>。</li></ul><h2 id="思路二：前缀和-单调队列"><a href="#思路二：前缀和-单调队列" class="headerlink" title="思路二：前缀和 + 单调队列"></a>思路二：前缀和 + 单调队列</h2><p>创建一个数组 <code>preSumArr</code> 用来保存 <code>nums</code> 数组的前缀和。<br>然后使用前缀和的差来计算 子数组 的和，对应的长度就是两个前缀和的下标差。</p><p>那么怎么减少运算量呢？</p><p>需要理清下面两点(<code>a</code> &#x3D; <code>preSumArr[i+m]</code>,<code>b</code> &#x3D; <code>preSumArr[i]</code>)：</p><ul><li>当出现 <code>a - b &gt;= k</code> 时，是不是 <code>a</code> 后面的数据就不用和 <code>b</code> 数据进行比较了，因为无论怎么比他们的子数组都比 <code>m</code> 大。所以，<code>i</code> 位置的数据就用不着了。 </li><li>当 <code>a</code> 与 <code>b</code> 之间存在着一个数 <code>c</code> 比 <code>b</code> 小。那么如果 <code>a - b &gt;= k</code> 成立，那么一定会有 <code>a - c &gt;= k</code> 成立，子数组的长度是不是比 <code>m</code> 小？所以当出现了这么个数 <code>c</code> 时，<code>i</code> 位置的数据就用不着了 。</li></ul><p>根据以上2点可以创建一个队列 <code>queue</code> 用来增、删前缀和数组的元素，只记录下标。</p><p>拿出数组 <code>preSumArr</code> 的元素，和队列最前的元素相比较。</p><p>若差大于等于 <code>k</code> ，则删除队列中的该元素，直到队列中所有的数与其差值都小于 <code>k</code>。</p><p>此时再将数组元素加入至队列中，并将队列中比其大的元素删除。</p><blockquote><p>此时思考一点，我们每次将数组元素加入队列前，都把比他大的元素删除，那么这个队列从始至终不都是一个递增排列的吗？</p></blockquote><p>所以删除元素都很简单，只需要移动队列的前后指针即可。</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> min(a,b) (a &lt; b ? a : b);</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shortestSubarray</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = numsSize + <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> preSumArr[numsSize+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> queue[numsSize+<span class="number">1</span>],front = <span class="number">0</span>,rear = <span class="number">0</span>;</span><br><span class="line">    preSumArr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//计算数组sums的前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; numsSize;i++)&#123;</span><br><span class="line">        preSumArr[i+<span class="number">1</span>] = preSumArr[i] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= numsSize;i++)&#123;</span><br><span class="line">        <span class="type">long</span> n = preSumArr[i];</span><br><span class="line">        <span class="comment">//删除队列的元素</span></span><br><span class="line">        <span class="keyword">while</span> ( rear != front &amp;&amp; n - preSumArr[queue[front]] &gt;= k)&#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans,i - queue[front]);</span><br><span class="line">            front++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除队列中比 n 大的数</span></span><br><span class="line">        <span class="keyword">while</span> ( rear != front &amp;&amp; n &lt;= preSumArr[queue[rear<span class="number">-1</span>]])&#123;</span><br><span class="line">            rear--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将数加入队列</span></span><br><span class="line">        queue[rear] = i;</span><br><span class="line">        rear ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans &gt; numsSize ? <span class="number">-1</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。</li><li>空间复杂度：<code>O (n)</code>。申请了两个长度为n的数组</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短的桥</title>
      <link href="/2022/10/25/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5/"/>
      <url>/2022/10/25/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5/</url>
      
        <content type="html"><![CDATA[<p>给你一个大小为 <code>n * n</code> 的二元矩阵 <code>grid</code> ，其中 <code>1</code> 表示陆地，<code>0</code> 表示水域。</p><p>岛是由一片为的 <code>1</code> 形成的一个最大组，即不会与非组内的任何其他 <code>1</code> 相连。<code>grid</code> 中 恰好存在两座岛 。</p><p>你可以将任意数量的 <code>0</code> 变为 <code>1</code> ，以使两座岛连接起来，变成 一座岛 。</p><p>返回必须翻转的 <code>0</code> 的最小数目。</p><p> <span id="more"></span></p><p>示例 1：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = <span class="string">[[0,1],[1,0]]</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = <span class="string">[[0,1,0],[0,0,0],[0,0,1]]</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = <span class="comment">[<span class="comment">[1,1,1,1,1]</span>,<span class="comment">[1,0,0,0,1]</span>,<span class="comment">[1,0,1,0,1]</span>,<span class="comment">[1,0,0,0,1]</span>,<span class="comment">[1,1,1,1,1]</span>]</span></span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h2 id="思路一：广度优先搜索"><a href="#思路一：广度优先搜索" class="headerlink" title="思路一：广度优先搜索"></a>思路一：广度优先搜索</h2><p>题目中求最少的翻转 <code>0</code> 的数目等价于求矩阵中两个岛的最短距离，因此我们可以广度优先搜索来找到矩阵中两个块的最短距离。首先找到其中一座岛，然后将其不断向外延伸一圈，直到到达了另一座岛，延伸的圈数即为最短距离。广度优先搜索时，我们可以将已经遍历过的位置标记为 <code>−1</code>，实际计算过程如下：</p><ul><li>我们通过遍历找到数组 <code>grid</code> 中的 <code>1</code> 后进行广度优先搜索，此时可以得到第一座岛的位置集合，记为 <code>island</code> ，并将其位置全部标记为 <code>−1</code>。</li><li>随后我们从 <code>island</code> 中的所有位置开始进行广度优先搜索，当它们到达了任意的 <code>1</code> 时，即表示搜索到了第二个岛，搜索的层数就是答案。</li></ul><p>别看代码长，其实很容易理解。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> shortestBridge(<span class="built_in">int</span>** grid, <span class="built_in">int</span> gridSize, <span class="built_in">int</span>* gridColSize) &#123;</span><br><span class="line">    <span class="built_in">int</span> n = gridSize;</span><br><span class="line">    <span class="built_in">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//构造一个 island 和队列 queue，island记录第一块岛。</span></span><br><span class="line">    <span class="built_in">int</span> *island = (<span class="built_in">int</span> *)malloc(sizeof(<span class="built_in">int</span>) * n * n); </span><br><span class="line">    <span class="built_in">int</span> *queue = (<span class="built_in">int</span> *)malloc(sizeof(<span class="built_in">int</span>) * n * n);</span><br><span class="line">    <span class="built_in">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 队列记录第一次出现值为 1 的坐标 (i,j)</span></span><br><span class="line">                queue[tail++] = i * n + j;</span><br><span class="line">                grid[i][j] = <span class="number">-1</span>;</span><br><span class="line">                <span class="built_in">int</span> islandSize = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (head != tail) &#123;</span><br><span class="line">                    <span class="comment">// (x,y) 即是记录的 (i,j)</span></span><br><span class="line">                    <span class="built_in">int</span> x = queue[head] / n;</span><br><span class="line">                    <span class="built_in">int</span> y = queue[head] % n;</span><br><span class="line">                    island[islandSize++] = queue[head];</span><br><span class="line">                    head++;</span><br><span class="line">                    <span class="comment">//搜索值为 1 周围 4 个方块是否有 1， 如果有则将值为 1 的坐标添加到队列 queue</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        <span class="built_in">int</span> nx = x + dirs[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="built_in">int</span> ny = y + dirs[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="comment">// 考虑边界问题，判断坐标(x,y)的周围4个坐标是否出界</span></span><br><span class="line">                        <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n &amp;&amp; grid[nx][ny] == <span class="number">1</span>) &#123;</span><br><span class="line">                            queue[tail++] = nx * n + ny;</span><br><span class="line">                            grid[nx][ny] = <span class="number">-1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//刚已经把 所有值为 1 的坐标全部记录进数组 island 中，并且把值修改为 -1；</span></span><br><span class="line">                <span class="comment">//现在要将其中一块岛屿 island 中所有坐标加载到队列中，</span></span><br><span class="line">                head = tail = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; islandSize; i++) &#123;</span><br><span class="line">                    queue[tail++] = island[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">int</span> step = <span class="number">0</span>;<span class="comment">//step记录需要翻转 0 的个数。</span></span><br><span class="line">                <span class="keyword">while</span> (head != tail) &#123;</span><br><span class="line">                    <span class="comment">//接下来就是将 值为 -1 的坐标周围一圈的 0 全翻转为 -1。sz 为队列长度</span></span><br><span class="line">                    <span class="built_in">int</span> sz = tail - head;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                        <span class="built_in">int</span> x = queue[head] / n;</span><br><span class="line">                        <span class="built_in">int</span> y = queue[head] % n;</span><br><span class="line">                        head++;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                            <span class="built_in">int</span> nx = x + dirs[k][<span class="number">0</span>];</span><br><span class="line">                            <span class="built_in">int</span> ny = y + dirs[k][<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n) &#123;</span><br><span class="line">                                <span class="comment">//开始翻转 0 ；</span></span><br><span class="line">                                <span class="keyword">if</span> (grid[nx][ny] == <span class="number">0</span>) &#123;</span><br><span class="line">                                    queue[tail++] = nx * n + ny;</span><br><span class="line">                                    grid[nx][ny] = <span class="number">-1</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[nx][ny] == <span class="number">1</span>) &#123;</span><br><span class="line">                                    <span class="comment">//如果在这片区域搜寻到 1 则说明已经翻转完成</span></span><br><span class="line">                                    free(queue);</span><br><span class="line">                                    free(island);</span><br><span class="line">                                    <span class="keyword">return</span> step;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    step++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(n^2)</code></li><li>空间复杂度：<code>O(n^2)</code></li></ul><h2 id="思路二：深度优先搜索-广度优先搜索"><a href="#思路二：深度优先搜索-广度优先搜索" class="headerlink" title="思路二：深度优先搜索 + 广度优先搜索"></a>思路二：深度优先搜索 + 广度优先搜索</h2><p>解法思路与思路一类似，我们可以利用深度优先搜索求出其中的一座岛，然后利用广度优先搜索来找到两座岛的最短距离。深度度优先搜索时，我们可以将已经遍历过的位置标记为 <code>−1</code>，实际计算过程如下：</p><ul><li>我们通过遍历找到数组 <code>grid</code> 中的 <code>1</code> 后进行深度优先搜索，此时可以得到第一座岛的位置集合，记为 <code>island</code> ，并将其位置全部标记为 <code>−1</code>。</li><li>随后我们从 <code>island</code> 中的所有位置开始进行广度优先搜索，当它们到达了任意的 <code>1</code> 时，即表示搜索到了第二个岛，搜索的层数就是答案。</li></ul><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*该函数所表达的意思：</span></span><br><span class="line"><span class="comment">    坐标(x,y) 的值为 1 则加入至队列 queue 中，</span></span><br><span class="line"><span class="comment">    坐标(x,y) 周围与之相连的 1 也加入至队列 queue 中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">void</span> dfs(<span class="built_in">int</span> x, <span class="built_in">int</span> y, <span class="built_in">int</span>** grid, <span class="built_in">int</span> n, <span class="built_in">int</span> *queue, <span class="built_in">int</span> *tail) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= n || y &gt;= n || grid[x][y] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[(*tail)++] = x * n + y;</span><br><span class="line">    grid[x][y] = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//四个dfs函数对应了4个方向的坐标</span></span><br><span class="line">    dfs(x - <span class="number">1</span>, y, grid, n, queue, tail);</span><br><span class="line">    dfs(x + <span class="number">1</span>, y, grid, n, queue, tail);</span><br><span class="line">    dfs(x, y - <span class="number">1</span>, grid, n, queue, tail);</span><br><span class="line">    dfs(x, y + <span class="number">1</span>, grid, n, queue, tail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> shortestBridge(<span class="built_in">int</span>** grid, <span class="built_in">int</span> gridSize, <span class="built_in">int</span>* gridColSize) &#123;</span><br><span class="line">    <span class="built_in">int</span> n = gridSize;</span><br><span class="line">    <span class="built_in">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">int</span> *queue = (<span class="built_in">int</span> *)malloc(sizeof(<span class="built_in">int</span>) * n * n);</span><br><span class="line">                <span class="built_in">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line">                dfs(i, j, grid, n, queue, &amp;tail);</span><br><span class="line">                <span class="built_in">int</span> step = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//此时队列 queue 已经将其中一块岛的所有坐标保存下来了。</span></span><br><span class="line">                <span class="keyword">while</span> (head != tail) &#123;</span><br><span class="line">                    <span class="built_in">int</span> sz = tail - head;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                        <span class="built_in">int</span> x = queue[head] / n;</span><br><span class="line">                        <span class="built_in">int</span> y = queue[head] % n;</span><br><span class="line">                        head++;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                            <span class="built_in">int</span> nx = x + dirs[k][<span class="number">0</span>];</span><br><span class="line">                            <span class="built_in">int</span> ny = y + dirs[k][<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (grid[nx][ny] == <span class="number">0</span>) &#123;</span><br><span class="line">                                    queue[tail++] = nx * n + ny;</span><br><span class="line">                                    grid[nx][ny] = <span class="number">-1</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[nx][ny] == <span class="number">1</span>) &#123;</span><br><span class="line">                                    free(queue);</span><br><span class="line">                                    <span class="keyword">return</span> step;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    step++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(n^2)</code></li><li>空间复杂度：<code>O(n^2)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 广度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无重复字符的最长子串</title>
      <link href="/2022/10/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2022/10/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 最长子串 的长度。</p><span id="more"></span><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;abcabcbb&quot;</span></span><br><span class="line"><span class="section">输出: 3 </span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;bbbbb&quot;</span></span><br><span class="line"><span class="section">输出: 1</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span></span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;pwwkew&quot;</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span></span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p>提示：</p><p><code>0 &lt;= s.length &lt;=  5 * 104</code><br><code>s</code> 由英文字母、数字、符号和空格组成</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>这道题主要用到思路是：滑动窗口</p><p>什么是滑动窗口？</p><p>其实就是一个队列,比如例题中的 <code>abcabcbb</code> ，进入这个队列（窗口）为 <code>abc</code> 满足题目要求，当再进入 <code>a</code>，队列变成了 <code>abca</code>，这时候不满足要求。所以，我们要移动这个队列！</p><p>如何移动？</p><p>如何才能高效地移动这个队列，使得这个队列一直满足要求呢？那就得用到哈希表。<br>创建哈希表 <code>hash</code> 记录搜索的每一个字符最后出现的位置，每当出现一个字符，就将他的位置记录下来 <code>hash[s[rear]] = rear + 1</code> ，当队列进入一个字符时，使得队列中有两个字符相同时，我们就可以利用 <code>hash</code> 表快速的将左边那个字符移出去。</p><p>一直维持这样的队列，找出队列出现最长的长度时候，即可求出解！</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="type">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hash[<span class="number">127</span>] = &#123;<span class="number">0</span>&#125;,max = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>,rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[rear])&#123;</span><br><span class="line">        <span class="comment">//当在对列front下标的右侧出现2个相同的字符时，移动front。</span></span><br><span class="line">        <span class="keyword">if</span>(front &lt; hash[s[rear]])</span><br><span class="line">            front = hash[s[rear]];</span><br><span class="line">        max = max &gt; rear + <span class="number">1</span> - front ? max : rear + <span class="number">1</span> - front;</span><br><span class="line">        hash[s[rear]] = rear + <span class="number">1</span>;</span><br><span class="line">        rear++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。n为字符串长度</li><li>空间复杂度：<code>O (1)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hash表 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不同路径II</title>
      <link href="/2022/10/23/%E7%AE%97%E6%B3%95%E9%A2%98/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/"/>
      <url>/2022/10/23/%E7%AE%97%E6%B3%95%E9%A2%98/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/</url>
      
        <content type="html"><![CDATA[<p>一个机器人位于一个 <code>m * n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="/./../../img/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II%202.jpg"></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacleGrid = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="number">3</span>x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 <span class="number">2</span> 条不同的路径：</span><br><span class="line"><span class="number">1.</span> 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line"><span class="number">2.</span> 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/./../../img/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II%201.jpg"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacleGrid = <span class="string">[[0,1],[0,0]]</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="思路：动态规划"><a href="#思路：动态规划" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h2><p>不同路径II 可以用<a href="./%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.md">不同路径</a>的动态规划代码完成，不过要让有障碍物的位置 <code>f[i][j]</code> 应该为 <code>0</code>。</p><p>现在还有一种叫做滚动数组，也就是说，这个数组 <code>f</code> 是在滚动的<br><br/><br>什么意思呢？就是说 <code>i = 0</code> 时的数组和 <code>i = 1</code> 时的数组表达的东西不一样，<code>i</code> 的值就代表了这个数组表示的是第 <code>i</code> 行对应的数组。</p><blockquote><p><code>f[j] = f[j - 1] + f[j]</code></p></blockquote><blockquote><p><code>f(i,j) = f(i−1,j) + f(i,j−1)</code></p></blockquote><p>两者是等价的。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int uniquePathsWithObstacles(int** obstacleGrid, int obstacleGridSize, int* obstacleGridColSize)&#123;</span><br><span class="line">    int n = obstacleGridSize, m = obstacleGridColSize<span class="comment">[0]</span>;</span><br><span class="line">    int f<span class="comment">[m]</span>;</span><br><span class="line">    memset(f, 0, sizeof(f));</span><br><span class="line">    f<span class="comment">[0]</span> = (obstacleGrid<span class="comment">[0]</span><span class="comment">[0]</span> == 0);</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">            if (obstacleGrid<span class="comment">[i]</span><span class="comment">[j]</span> == 1) &#123;</span><br><span class="line">                f<span class="comment">[j]</span> = 0;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (j - 1 &gt;= 0 &amp;&amp; obstacleGrid<span class="comment">[i]</span><span class="comment">[j - 1]</span> == 0) &#123;</span><br><span class="line">                f<span class="comment">[j]</span> += f<span class="comment">[j - 1]</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f<span class="comment">[m - 1]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (m * n)</code>。</li><li>空间复杂度：<code>O (m)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不同路径</title>
      <link href="/2022/10/23/%E7%AE%97%E6%B3%95%E9%A2%98/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
      <url>/2022/10/23/%E7%AE%97%E6%B3%95%E9%A2%98/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p>一个机器人位于一个 <code>m * n</code> 网格的左上角（起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="/./../../img/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.png"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, <span class="built_in">n</span> = <span class="number">7</span></span><br><span class="line">输出：<span class="number">28</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 <span class="number">3</span> 条路径可以到达右下角。</span><br><span class="line"><span class="number">1.</span> 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line"><span class="number">2.</span> 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line"><span class="number">3.</span> 向下 -&gt; 向右 -&gt; 向下</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">7</span>, <span class="built_in">n</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="number">28</span></span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, <span class="built_in">n</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="解题思路-一-：动态规划"><a href="#解题思路-一-：动态规划" class="headerlink" title="解题思路(一)：动态规划"></a>解题思路(一)：动态规划</h2><p>用二维数组<code>f(i, j)</code> 表示从左上角走到 <code>(i, j)</code> 的路径数量。</p><p>由于我们每一步只能从向下或者向右移动一步，因此要想走到 <code>(i, j)</code>，如果向下走一步，那么会从 <code>(i-1, j)</code> 走过来；如果向右走一步，那么会从 <code>(i, j-1)</code> 走过来。因此我们可以写出动态规划转移方程：</p><blockquote><p><code>f(i,j) = f(i−1,j) + f(i,j−1)</code></p></blockquote><p>但是由于第一行与第一列在边界，所以只能为 <code>1</code> 。</p><p>简单的来说就像是个杨辉三角。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int uniquePaths(int m, int n) &#123;</span><br><span class="line">    int f<span class="comment">[m]</span><span class="comment">[n]</span>;</span><br><span class="line">    f<span class="comment">[0]</span><span class="comment">[0]</span> = 1;</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            if(i = 0 &amp;&amp; j &gt; 0)&#123;</span><br><span class="line">                f<span class="comment">[0]</span><span class="comment">[j]</span> = f<span class="comment">[0]</span><span class="comment">[j - 1]</span>;</span><br><span class="line">            &#125;else if(j = 0 &amp;&amp; i &gt; 0)&#123;</span><br><span class="line">                f<span class="comment">[i]</span><span class="comment">[0]</span> = f<span class="comment">[i - 1]</span><span class="comment">[0]</span>;</span><br><span class="line">            &#125;else if(i &gt; 0 &amp;&amp;j &gt; 0)&#123;</span><br><span class="line">                f<span class="comment">[i]</span><span class="comment">[j]</span> = f<span class="comment">[i - 1]</span><span class="comment">[j]</span> + f<span class="comment">[i]</span><span class="comment">[j - 1]</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f<span class="comment">[m - 1]</span><span class="comment">[n - 1]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(m * n)</code></li><li>空间复杂度：<code>O(m * n)</code></li></ul><h2 id="解题思路-二-：排列组合原理"><a href="#解题思路-二-：排列组合原理" class="headerlink" title="解题思路(二)：排列组合原理"></a>解题思路(二)：排列组合原理</h2><p>这个机器人总共需要走 <code>m + n -2</code> 步走到终点。其中有 <code>m - 1</code> 步是向下走的， <code>n - 1</code> 步是向右走的。利用排列组合知识，可以得出总共需要走 C<sub>n-1</sub><sup style="margin-left:-20px">m+n-2</sup> 步，意思就是从 <code>m + n -2</code> 步中选择 <code>n - 1</code> 步向右其余向左。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> unique<span class="constructor">Paths(<span class="params">int</span> <span class="params">m</span>, <span class="params">int</span> <span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//保证n更小。</span></span><br><span class="line">    <span class="keyword">if</span> (m &lt; n)</span><br><span class="line">        return unique<span class="constructor">Paths(<span class="params">n</span> , <span class="params">m</span>)</span>;</span><br><span class="line">    <span class="comment">//计算路径条数</span></span><br><span class="line">    <span class="built_in">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        ans = ans<span class="operator"> * </span>(m + i - <span class="number">1</span>)<span class="operator"> / </span>i; </span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(min(n,m))</code>;</li><li>空间复杂度：<code>O(1)</code>;</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串相乘</title>
      <link href="/2022/10/20/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/"/>
      <url>/2022/10/20/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
      
        <content type="html"><![CDATA[<p>给定两个以字符串形式表示的非负整数  <code>num1</code>  和  <code>num2</code>，返回  <code>num1</code>  和  <code>num2</code>  的乘积，它们的乘积也表示为字符串形式。</p><span id="more"></span><p>注意：不能使用任何内置的 <code>BigInteger</code> 库或直接将输入转换为整数。</p><p>示例 1:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="symbol">num1</span> = <span class="string">&quot;2&quot;</span>, <span class="symbol">num2</span> = <span class="string">&quot;3&quot;</span></span><br><span class="line">输出: <span class="string">&quot;6&quot;</span></span><br></pre></td></tr></table></figure><p>示例  2:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="symbol">num1</span> = <span class="string">&quot;123&quot;</span>, <span class="symbol">num2</span> = <span class="string">&quot;456&quot;</span></span><br><span class="line">输出: <span class="string">&quot;56088&quot;</span></span><br></pre></td></tr></table></figure><p>提示：</p><p><code>1 &lt;= num1.length, num2.length &lt;= 200</code></p><p><code>num1</code>  和 <code>num2</code>  只能由数字组成。</p><p><code>num1</code>  和 <code>num2</code>  都不包含任何前导零，除了数字 0 本身。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>该算法是通过两数相乘时，乘数某位与被乘数某位相乘，与产生结果的位置的规律来完成。具体规律如下：</p><p>乘数 <code>num1</code> 位数为 <code>s1</code>，被乘数 <code>num2</code> 位数为 <code>s2</code>， <code>num1 x num2</code> 结果 <code>num3</code> 最大总位数为 <code>s1+s2</code><br><code>num1[i] x num2[j]</code> 的结果为 <code>value</code>(位数为两位，”0x”,”xy”的形式)，其第一位位于 <code>num3[i+j]</code>，第二位位于 <code>num3[i+j+1]</code>。</p><p>结合下图更容易理解:</p><p><img src="/./../../img/topic/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%98%E6%B3%95.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">multiply</span><span class="params">(<span class="type">char</span> * num1, <span class="type">char</span> * num2)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s1 = <span class="built_in">strlen</span>(num1);</span><br><span class="line">    <span class="type">int</span> s2 = <span class="built_in">strlen</span>(num2);</span><br><span class="line">    <span class="type">char</span> *num3 = (<span class="type">char</span> *)<span class="built_in">malloc</span>((s1+s2+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="comment">//将num3全所有字符变为0，再在结尾加上&#x27;\0&#x27;;</span></span><br><span class="line">    <span class="built_in">memset</span>(num3,<span class="string">&#x27;0&#x27;</span>,s1 + s2 );</span><br><span class="line">    num3[s1 + s2] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//从后往前遍历，可以避免进位问题。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s1 - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = s2 - <span class="number">1</span>;j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="type">int</span> value = num3[i + j + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> + (num1[i] - <span class="string">&#x27;0&#x27;</span>) * (num2[j] - <span class="string">&#x27;0&#x27;</span>) ;</span><br><span class="line">            num3[i + j] += value / <span class="number">10</span>;</span><br><span class="line">            num3[i + j + <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span> + value % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分3种情况输出</span></span><br><span class="line">    <span class="keyword">if</span>(num3[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; num3[<span class="number">1</span>] &amp;&amp; num3[<span class="number">1</span>] != <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">//首位为0，但结果不为0，直接舍去第一个字符</span></span><br><span class="line">        <span class="keyword">return</span> num3 + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num3[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">//结果为0输出0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//直接输出num3</span></span><br><span class="line">        <span class="keyword">return</span> num3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (M * N)</code>。 M,N 分别为 num1 和 num2 的长度。</li><li>空间复杂度：<code>O (M + N)</code>。 用于存储计算结果。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缺失的第一个正数</title>
      <link href="/2022/10/19/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/"/>
      <url>/2022/10/19/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p><p>实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [1,2,0]</span></span><br><span class="line"><span class="string">输出：3</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [3,4,-1,1]</span></span><br><span class="line"><span class="string">输出：2</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="string">[7,8,9,11,12]</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="思路：原地哈希表"><a href="#思路：原地哈希表" class="headerlink" title="思路：原地哈希表"></a>思路：原地哈希表</h2><br/><ul><li><p>要求时间复杂度为 <code>O(n)</code> ，很容易想到是把数组里面的所有正数放到哈希表中，再利用一次遍历即可找出缺失的最小正数。但是这样，空间复杂度就也变成了 <code>O(n)</code> 不符合题目所说的常数级了。<br>在这上面进行改进，把原有的数组空间看成一个哈希表，也就是原地哈希表。</p></li><li><p>那么，我们可以采取这样的思路：就把 <code>1</code> 这个数放到下标为 <code>0</code> 的位置， <code>2</code> 这个数放到下标为 <code>1</code> 的位置，按照这种思路整理一遍数组。然后我们再遍历一次数组，第 <code>1</code> 个遇到的它的值不等于下标的那个数，就是我们要找的缺失的第一个正数。</p></li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int firstMissingPositive(int* nums, int numsSize)&#123;</span><br><span class="line">    for(int i = 0 ; i &lt; numsSize;i++)&#123;</span><br><span class="line">        while (nums<span class="comment">[i]</span> != i + 1)&#123;</span><br><span class="line">            if (nums<span class="comment">[i]</span> &lt;= 0 || nums<span class="comment">[i]</span> &gt; numsSize || nums<span class="comment">[i]</span> == nums<span class="comment">[nums<span class="comment">[i]</span> - 1]</span>)</span><br><span class="line">                break;</span><br><span class="line">            // 将nums<span class="comment">[i]</span> 放置到对应位置上<span class="comment">[1,2,3...]</span></span><br><span class="line">            int idx = nums<span class="comment">[i]</span> - 1;</span><br><span class="line">            nums<span class="comment">[i]</span> = nums<span class="comment">[idx]</span>;</span><br><span class="line">            nums<span class="comment">[idx]</span> = idx + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; numsSize ;i++) &#123;</span><br><span class="line">        if (nums<span class="comment">[i]</span> != (i + 1)) &#123;</span><br><span class="line">            return (i + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return numsSize + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。遍历了整个数组一遍。</li><li>空间复杂度：<code>O (1)</code>。原地哈希表，没有申请额外的线性空间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> hash表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索旋转数组</title>
      <link href="/2022/10/18/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
      <url>/2022/10/18/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>整数数组 <code>nums</code> 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 <code>k（0 &lt;= k &lt; nums.length）</code>上进行了 旋转，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 <code>0</code> 开始 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>时间复杂度必须为 O(log n)。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="string">[4,5,6,7,0,1,2]</span>, target = <span class="number">0</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="string">[4,5,6,7,0,1,2]</span>, target = <span class="number">3</span></span><br><span class="line">输出：-<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>], <span class="keyword">target</span> = <span class="number">0</span></span><br><span class="line">输出：<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 中的每个值都 独一无二</li><li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><h2 id="思路：二分法"><a href="#思路：二分法" class="headerlink" title="思路：二分法"></a>思路：二分法</h2><ul><li>二分查找</li></ul><p>对于我们来说更熟悉于查找 递增数组 <code>[0,1,2,4,5,6,7]</code> 中的值。</p><p>那么对于旋转后的数组 <code>[4,5,6,7,0,1,2]</code> 我们不太熟练。所以我们就把这个数组转化成我们熟知的问题，也就是把数组 <code>[4,5,6,7,0,1,2]</code> 重新旋转回去，那么怎么做呢？</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">4,5,6,7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"> ^ ^ ^ ^</span><br><span class="line">[<span class="number">4,5,6,7</span>,<span class="number">0,1,2,4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">               ^ ^ ^ ^</span><br></pre></td></tr></table></figure><p>把数组 <code>[4,5,6,7,0,1,2]</code> 看成循环数组:<br><code>[4,5,6,7,0,1,2,4,5,6,7,0,1,2,······]</code><br>然后取出最前面的有序数组 <code>[0,1,2,4,5,6,7]</code> ，进行二分查找。<br>找到最小元素 <code>0</code> 的下标 <code>i</code> ,作为最低位，则最高位为 <code>i - 1 + numsSize</code><br>可以利用循环数组的特性: <code>a[n] = a[n % numsSize]</code><br>可以不用重新申请空间做数组，最后进行代码实现。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> <span class="keyword">target</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; numsSize;i++)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[i<span class="number">-1</span>]) low = i;</span><br><span class="line">    <span class="keyword">int</span> high = low - <span class="number">1</span> + numsSize;</span><br><span class="line">    <span class="comment">//利用二分法查找元素 </span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid % numsSize] &lt; <span class="keyword">target</span>)&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(nums[mid % numsSize] &gt; <span class="keyword">target</span>)</span></span>&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mid % numsSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。主要是遍历用的时间多，二分使用的时间是log级别的，相比于线性可以忽略不计</li><li>空间复杂度：<code>O (1)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K 个一组翻转链表</title>
      <link href="/2022/10/17/%E7%AE%97%E6%B3%95%E9%A2%98/K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/10/17/%E7%AE%97%E6%B3%95%E9%A2%98/K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><span id="more"></span><p><strong>示例1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="string">[2,1,4,3,5]</span></span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="string">[3,2,1,4,5]</span></span><br></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>将 <code>n</code> 个节点 <code>k</code> 个 <code>k</code> 个分为一组。每一组进行一次反转。 可以查看【<a href="./%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.md">反转链表</a>】</p><ul><li><p>若不足 <code>k</code> 个节点，则直接返回 <code>head</code> </p></li><li><p>若足够 <code>k</code> 个节点，则进行下一步操作；</p></li></ul><p>最后利用递归即可完成。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">val</span>;</span><br><span class="line">    <span class="keyword">struct</span> ListNode *next;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="keyword">struct</span> ListNode* reverse<span class="constructor">KGroup(<span class="params">struct</span> ListNode<span class="operator">*</span> <span class="params">head</span>, <span class="params">int</span> <span class="params">k</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> ListNode *tempNode = head;</span><br><span class="line">    <span class="comment">//查看剩余长度是否大于k，若不大于则直接返回头节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span> ;i &lt; k;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (tempNode<span class="operator"> == </span>NULL)</span><br><span class="line">            return head;</span><br><span class="line">        tempNode = tempNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用来保存头节点和尾节点</span></span><br><span class="line">    <span class="keyword">struct</span> ListNode *newListHead = NULL;</span><br><span class="line">    <span class="keyword">struct</span> ListNode *newListTail = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">            tempNode = head-&gt;next;</span><br><span class="line">            head-&gt;next = newListHead;</span><br><span class="line">            newListHead = head;</span><br><span class="line">            head = tempNode;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//尾节点指向的是剩余未翻转的链表的头节点。</span></span><br><span class="line">    newListTail-&gt;next = reverse<span class="constructor">KGroup(<span class="params">tempNode</span>,<span class="params">k</span>)</span>;</span><br><span class="line">    return newListHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。链表长度</li><li>空间复杂度：<code>O (1)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两两交换节点</title>
      <link href="/2022/10/16/%E7%AE%97%E6%B3%95%E9%A2%98/%E2%80%9C%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E8%8A%82%E7%82%B9%E2%80%9D/"/>
      <url>/2022/10/16/%E7%AE%97%E6%B3%95%E9%A2%98/%E2%80%9C%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E8%8A%82%E7%82%B9%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><span id="more"></span><p>（<a href="./K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.md" title="K 个一组翻转链表">那如果不是两两交换，有可能是前k个节点发生翻转呢？这样该怎么做？</a>）</p><p><strong>示例1:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1,2,3,4</span>]</span><br><span class="line">输出：[<span class="number">2,1,4,3</span>]</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><p><strong>示例3:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[1]</span></span><br><span class="line">输出：<span class="comment">[1]</span></span><br></pre></td></tr></table></figure><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>每2个节点为一组，先完成链表的前2个节点操作，后面每组的操作相同，将第一个节点 <code>node1</code> 和第二个节点 <code>node2</code> 发生交换，然后把第三个节点 <code>node3(node2-&gt;next)</code> 看成新的 <code>node1</code> 进行下一轮的操作。</p><h3 id="递归代码："><a href="#递归代码：" class="headerlink" title="递归代码："></a>递归代码：</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* swapPairs(struct ListNode*<span class="built_in"> head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">(head</span> == NULL ||<span class="built_in"> head</span>-&gt;<span class="keyword">next</span> == NULL) &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="built_in"> head</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode* node1 =<span class="built_in"> head</span>;</span><br><span class="line">    struct ListNode* node2 =<span class="built_in"> head</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">    node1-&gt;<span class="keyword">next</span> = swapPairs(node2-&gt;<span class="keyword">next</span>);</span><br><span class="line">    node2-&gt;<span class="keyword">next</span> =<span class="built_in"> head</span>;</span><br><span class="line">    <span class="keyword">return</span> node2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。</li><li>空间复杂度：<code>O (n)</code>。 每次使用递归都会申请两个节点空间，故空间复杂度：<code>O (n)</code>。</li></ul><h3 id="迭代代码："><a href="#迭代代码：" class="headerlink" title="迭代代码："></a>迭代代码：</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* swapPairs(struct ListNode* head) &#123;</span><br><span class="line">    struct ListNode dummyHead;</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    <span class="comment">//temp是指向头节点的那个指针</span></span><br><span class="line">    struct ListNode* temp = &amp;dummyHead;</span><br><span class="line">    <span class="comment">//当第一个节点和第二个节点不为空时。</span></span><br><span class="line">    <span class="function"><span class="title">while</span> (temp-&gt;</span><span class="function"><span class="title">next</span> != NULL &amp;&amp; temp-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>next != NULL) &#123;</span><br><span class="line">        <span class="function"><span class="title">struct</span> ListNode* node1 = temp-&gt;</span>next;</span><br><span class="line">        <span class="function"><span class="title">struct</span> ListNode* node2 = temp-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>next;</span><br><span class="line">        <span class="function"><span class="title">temp</span>-&gt;</span>next = node2; <span class="comment">//头节点改为第二个节点</span></span><br><span class="line">        <span class="function"><span class="title">node1</span>-&gt;</span><span class="function"><span class="title">next</span> = node2-&gt;</span>next;<span class="comment">//第一个节点的下个节点为第三个节点</span></span><br><span class="line">        <span class="function"><span class="title">node2</span>-&gt;</span>next = node1; <span class="comment">//第二个节点指向第一个节点</span></span><br><span class="line">        temp = node1; <span class="comment">//temp指向了第三个节点，将第三个节点当成第一个节点，重新开始新一轮循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    return dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。</li><li>空间复杂度：<code>O (1)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并k个有序链表</title>
      <link href="/2022/10/15/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/10/15/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><h2 id="思路：递归"><a href="#思路：递归" class="headerlink" title="思路：递归"></a>思路：递归</h2><p>要解决 <code>k</code>个链表合成 的问题，就得先解决两个链表合成问题。</p><p><a href="./%E9%80%92%E5%BD%92%E4%BB%A5%E5%8F%8A%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8.md" title="合并两个链表">合并两个有序列表思路</a></p><p>已经知道两个链表怎么合成，接下来就是把每个链表两两合成。直到合成到一个链表为止。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">val</span>;</span><br><span class="line">    <span class="keyword">struct</span> ListNode *next;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">//合成两个链表的函数</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* merge<span class="constructor">TwoLists(<span class="params">struct</span> ListNode<span class="operator">*</span> <span class="params">l1</span>, <span class="params">struct</span> ListNode<span class="operator">*</span> <span class="params">l2</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* merge<span class="constructor">KLists(<span class="params">struct</span> ListNode<span class="operator">**</span> <span class="params">lists</span>, <span class="params">int</span> <span class="params">listsSize</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (listsSize<span class="operator"> == </span>NULL) <span class="comment">//排除0个链表合成</span></span><br><span class="line">        return NULL;</span><br><span class="line">    <span class="keyword">while</span> (listsSize &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//链表两两合成，直到合完为止。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span> ; i &lt; listsSize<span class="operator"> / </span><span class="number">2</span>;i++)&#123;</span><br><span class="line">            lists<span class="literal">[<span class="identifier">i</span>]</span> = merge<span class="constructor">TwoLists(<span class="params">lists</span>[<span class="params">i</span>] , <span class="params">lists</span>[<span class="params">listsSize</span> - <span class="params">i</span> - 1])</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        listsSize = ( listsSize + <span class="number">1</span> )<span class="operator"> / </span><span class="number">2</span>; <span class="comment">//合并完后还剩下的链表数量 </span></span><br><span class="line">    &#125;</span><br><span class="line">    return lists<span class="literal">[<span class="number">0</span>]</span>;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">//利用递归 完成两个链表的合并</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* merge<span class="constructor">TwoLists(<span class="params">struct</span> ListNode<span class="operator">*</span> <span class="params">l1</span>, <span class="params">struct</span> ListNode<span class="operator">*</span> <span class="params">l2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1<span class="operator"> == </span>NULL)&#123;</span><br><span class="line">        return l2;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (l2<span class="operator"> == </span>NULL)&#123;</span><br><span class="line">        return l1;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (l1 -&gt; <span class="keyword">val</span> &lt; l2 -&gt; <span class="keyword">val</span> )&#123;</span><br><span class="line">        l1 -&gt; next = merge<span class="constructor">TwoLists(<span class="params">l1</span> -&gt; <span class="params">next</span> , <span class="params">l2</span>)</span>;</span><br><span class="line">        return l1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        l2 -&gt; next = merge<span class="constructor">TwoLists(<span class="params">l2</span> -&gt; <span class="params">next</span> , <span class="params">l1</span>)</span>;</span><br><span class="line">        return l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (kn*logk)</code>。每个元素遍历k次，使用二分思想将k个链表合并，相当于 kn*logk 。</li><li>空间复杂度：<code>O (logk)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并两个有序列表</title>
      <link href="/2022/10/15/%E7%AE%97%E6%B3%95%E9%A2%98/%E9%80%92%E5%BD%92%E4%BB%A5%E5%8F%8A%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2022/10/15/%E7%AE%97%E6%B3%95%E9%A2%98/%E9%80%92%E5%BD%92%E4%BB%A5%E5%8F%8A%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>将两个升序链表合并为一个新的 <code>升序</code> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><span id="more"></span><br/><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：list1 = <span class="comment">[1,2,4]</span>, list2 = <span class="comment">[1,3,4]</span></span><br><span class="line">输出：<span class="comment">[1,1,2,3,4,4]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：list1 = <span class="comment">[]</span>, list2 = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><h2 id="思路-一：递归"><a href="#思路-一：递归" class="headerlink" title="思路 一：递归"></a>思路 一：递归</h2><p>这个就是把所有值从小到大串起来；值更小的节点指向一个比他值更大的一个节点；</p><p>也就是说可以利用递归定义两个列表的操作：</p><blockquote><p>list1[0] + merge(list1[1],list2) list1[0] &lt; list2[0]</p><p>list2[0] + merge(list1,list2[1]) list1[0] &gt;&#x3D; list2[0]<br>​</p></blockquote><p>也就是说，两个链表头部值较小的一个节点与剩下元素的 <code>merge</code> 操作结果合并;</p><p>但也要注意排除空链表。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">val</span>;</span><br><span class="line">    <span class="keyword">struct</span> ListNode *next;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* merge<span class="constructor">TwoLists(<span class="params">struct</span> ListNode<span class="operator">*</span> <span class="params">list1</span>, <span class="params">struct</span> ListNode<span class="operator">*</span> <span class="params">list2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list1<span class="operator"> == </span>NULL)&#123;</span><br><span class="line">        return list2;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (list2<span class="operator"> == </span>NULL)&#123;</span><br><span class="line">        return list1;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (list1 -&gt; <span class="keyword">val</span> &lt; list2 -&gt; <span class="keyword">val</span> )&#123;</span><br><span class="line">        list1 -&gt; next = merge<span class="constructor">TwoLists(<span class="params">list1</span> -&gt; <span class="params">next</span> , <span class="params">list2</span>)</span>;</span><br><span class="line">        return list1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        list2 -&gt; next = merge<span class="constructor">TwoLists(<span class="params">list2</span> -&gt; <span class="params">next</span> , <span class="params">list1</span>)</span>;</span><br><span class="line">        return list2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。</li><li>空间复杂度：<code>O (1)</code>。</li></ul><h2 id="思路-二：迭代"><a href="#思路-二：迭代" class="headerlink" title="思路 二：迭代"></a>思路 二：迭代</h2><p>我们也可以利用迭代来实现上面的算法。也就是说当list1 和list2 不为空时，只需要比较头节点的值的大小，小的那个节点添加到结果那里，当一个节点被添加，该链表的节点往后移一位。</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    int val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> *next;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>* <span class="title function_ invoke__">mergeTwoLists</span>(<span class="keyword">struct</span> <span class="title class_">ListNode</span>* list1, <span class="keyword">struct</span> <span class="title class_">ListNode</span>* list2)&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> *prehead = (<span class="keyword">struct</span> <span class="title class_">ListNode</span>*)<span class="title function_ invoke__">malloc</span>(<span class="title function_ invoke__">sizeof</span>(<span class="keyword">struct</span> <span class="title class_">ListNode</span>));</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> *prev = prehead;    </span><br><span class="line">    <span class="title function_ invoke__">while</span> (list1 != NULL &amp;&amp; list2 != NULL) &#123;</span><br><span class="line">        <span class="title function_ invoke__">if</span> (list1 <span class="punctuation">-&gt;</span> val &lt; list2 <span class="punctuation">-&gt;</span> val) &#123;</span><br><span class="line">            prev <span class="punctuation">-&gt;</span> next = list1;</span><br><span class="line">            list1 = list1 <span class="punctuation">-&gt;</span> next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev <span class="punctuation">-&gt;</span> next = list2;</span><br><span class="line">            list2 = list2 <span class="punctuation">-&gt;</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = prev <span class="punctuation">-&gt;</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">    prev <span class="punctuation">-&gt;</span> next = list1 == NULL ? list2 : list1;</span><br><span class="line">    <span class="keyword">return</span> prehead <span class="punctuation">-&gt;</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。</li><li>空间复杂度：<code>O (1)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 迭代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器盛水</title>
      <link href="/2022/10/13/%E7%AE%97%E6%B3%95%E9%A2%98/%E2%80%9C%E5%AE%B9%E5%99%A8%E7%9B%9B%E6%B0%B4%E2%80%9D/"/>
      <url>/2022/10/13/%E7%AE%97%E6%B3%95%E9%A2%98/%E2%80%9C%E5%AE%B9%E5%99%A8%E7%9B%9B%E6%B0%B4%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。<br>返回容器可以储存的最大水量。</p><span id="more"></span><p><strong>说明：</strong><br>你不能倾斜容器。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">1,8,6,2</span>,<span class="number">5,4,8,3</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">49</span> </span><br><span class="line">解释：图中垂直线代表输入数组 [<span class="number">1,8,6,2</span>,<span class="number">5,4,8,3</span>,<span class="number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="number">49</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="思路一：暴力法"><a href="#思路一：暴力法" class="headerlink" title="思路一：暴力法"></a>思路一：暴力法</h2><p>遍历数组每个元素，并计算出该元素下标的数组所形成的最大储水量，并保存在另一个数组中。</p><p>易知面积公式 ： min (height[j],height[i]) * (i - j);</p><p>时间复杂度 O(n^2)</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max(a,b) (a &gt; b ? a : b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a,b) (a &lt; b ? a : b)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(<span class="type">int</span>* height, <span class="type">int</span> heightSize)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> visit[heightSize];</span><br><span class="line">    <span class="built_in">memset</span>( visit , <span class="number">0</span> ,<span class="built_in">sizeof</span> (visit));</span><br><span class="line">    <span class="type">int</span> Max = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; heightSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            visit[i] = <span class="built_in">max</span>( (i - j) * <span class="built_in">min</span>(height[i],height[j]) ,visit[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Max = <span class="built_in">max</span>(Max,visit[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="思路二：双指针"><a href="#思路二：双指针" class="headerlink" title="思路二：双指针"></a>思路二：双指针</h2><p>面积是一个矩形，长乘高，那么要求面积最大，先让长最大，长最大时得出一个面积，当宽增大时，看面积是否增大。</p><p>利用双指针，一个指向数组头 <code>head</code> ，一个指向数组尾部 <code>tail</code> ，让 <code>height[head]</code> 与 <code>height[tail]</code> 中值小的那个向往间靠。</p><p>时间复杂度为O(n);</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define max(a,b) (a &gt; b ? a : b)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> maxArea(<span class="type">int</span>* height, <span class="type">int</span> heightSize)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">head</span> = <span class="number">0</span>,<span class="built_in">tail</span> = heightSize - <span class="number">1</span>,MAX = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">head</span> &lt; <span class="built_in">tail</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[<span class="built_in">tail</span>] &lt; height[<span class="built_in">head</span>]) &#123;</span><br><span class="line">            <span class="comment">//当宽变化时，求出面积，然后与最大面积相比，如果更大，则替代</span></span><br><span class="line">            MAX = <span class="built_in">max</span>(MAX, height[<span class="built_in">tail</span>] * (<span class="built_in">tail</span> - <span class="built_in">head</span>));</span><br><span class="line">            <span class="built_in">tail</span> --;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            MAX = <span class="built_in">max</span>(MAX, height[<span class="built_in">head</span>] * (<span class="built_in">tail</span> - <span class="built_in">head</span>));</span><br><span class="line">            <span class="built_in">head</span> ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。</li><li>空间复杂度：<code>O (1)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找数组中的中位数</title>
      <link href="/2022/10/10/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2022/10/10/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong>。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = <span class="comment">[1,3]</span>, nums2 = <span class="comment">[2]</span></span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = <span class="comment">[1,2,3]</span> ，中位数 2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="symbol">nums1</span> = [<span class="number">1</span>,<span class="number">2</span>], <span class="symbol">nums2</span> = [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">2.50000</span></span><br><span class="line">解释：合并数组 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] ，中位数 <span class="comment">(2 + 3)</span> / <span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>由于题目中要求时间复杂度为 <code>O(log (m+n))</code> 使用普通的遍历方法肯定是达不到要求的。要产生log的话一般是要使用二分法来解题。</p><br/><ul><li>二分法</li></ul><p>把两个数组的所有数据平均分成两个数组，用两个板隔开，两个板的左边一个，右边为一个。<br>两个板的位置分别记为 <code>array1</code> 和 <code>array2</code> 那么要找到中位数，只需要保证<br>第一块板左边最大的数 小于 第二块板右边最小的数 即 <code>Lmax1 &lt; Rmin2</code> 和<br>第二块板左边最大的数 小于 第一块板右边最小的数 即 <code>Lmax2 &lt; Rmin1</code> 。</p><p>那么现在就是两块板放置的问题，我们一开始把两个板放在两个数组的最中间，<br>当 <code>Lmax1 &gt; Rmin2</code>时，第一块板往左移，使 <code>Lmax1</code> 变小。同理 当 <code>Lmax2 &gt; Rmin1</code> 时，第一块板往右移，使 <code>Rmin1</code> 变小。<br>因为要保证板两边的数量相同，那么第一块板向左移多少，第二块板就得往反方向移多少，<br>即 <code>array1 + array2 = m + n</code> 。<br>移动板，直到满足 <code>Lmax1 &lt; Rmin2 &amp;&amp; Lmax2 &lt; Rmin1</code> 。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#define max(a,b) (a &gt; b ? a : b)</span><br><span class="line">#define min(a,b) (a &lt; b ? a : b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> findMedianSortedArrays(<span class="built_in">int</span>* nums1, <span class="built_in">int</span> nums1Size, <span class="built_in">int</span>* nums2, <span class="built_in">int</span> nums2Size)&#123;</span><br><span class="line">    <span class="built_in">int</span> n = nums1Size, m = nums2Size;</span><br><span class="line">    <span class="comment">//确保第一个数组最短。</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; m)&#123;</span><br><span class="line">        <span class="keyword">return</span> findMedianSortedArrays(nums2, m,  nums1, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> Lmax1,Lmax2,Rmin1,Rmin2,<span class="built_in">array</span>1,<span class="built_in">array</span>2,head = <span class="number">0</span>,tail = <span class="number">2</span> * n;</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail)&#123;</span><br><span class="line">        <span class="built_in">array</span>1 = (head + tail) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">array</span>2 = n + m - <span class="built_in">array</span>1;</span><br><span class="line"></span><br><span class="line">        Lmax1 = (<span class="built_in">array</span>1 == <span class="number">0</span>) ? INT_MIN : nums1[(<span class="built_in">array</span>1 - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">        Rmin1 = (<span class="built_in">array</span>1 == <span class="number">2</span> * n) ? INT_MAX : nums1[<span class="built_in">array</span>1 / <span class="number">2</span>];</span><br><span class="line">        Lmax2 = (<span class="built_in">array</span>2 == <span class="number">0</span>) ? INT_MIN : nums2[(<span class="built_in">array</span>2 - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">        Rmin2 = (<span class="built_in">array</span>2 == <span class="number">2</span> * m) ? INT_MAX : nums2[<span class="built_in">array</span>2 / <span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (Lmax1 &gt; Rmin2)&#123;</span><br><span class="line">            tail = <span class="built_in">array</span>1 - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (Lmax2 &gt; Rmin1)&#123;</span><br><span class="line">            head = <span class="built_in">array</span>1 + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  ( max(Lmax1,Lmax2) + min(Rmin1,Rmin2) ) / <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (log(m + n))</code>。</li><li>空间复杂度：<code>O (1)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="/2022/10/04/Markdown/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/10/04/Markdown/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><p>相比WYSIWYG编辑器</p><p><strong>优点：</strong></p><ol><li><p>因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。</p></li><li><p>操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可</p></li></ol><br/><p><strong>缺点：</strong></p><ol><li><p>需要记一些语法（当然，是很简单。五分钟学会）。</p></li><li><p>有些平台不支持Markdown编辑模式。</p></li></ol> <span id="more"></span><br/><p>还好，简书是支持Markdown编辑模式的。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开启方式：设置-&gt;默认编辑器-&gt;Markdown编辑器</span><br></pre></td></tr></table></figure><h1 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h1><p>在想要设置为标题的文字前面加#来表示</p><p>一个#是一级标题，二个#是二级标题，以此 <code>类推</code>。支持六级标题。</p><br/> <p>注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。</p><br/><p>示例：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure><p>效果如下：</p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><hr><h1 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h1><ul><li><strong>加粗</strong></li></ul><p>要加粗的文字左右分别用两个*号包起来</p><ul><li><strong>斜体</strong></li></ul><p>要倾斜的文字左右分别用一个*号包起来</p><ul><li><strong>斜体加粗</strong></li></ul><p>要倾斜和加粗的文字左右分别用三个*号包起来</p><ul><li><strong>删除线</strong></li></ul><p>要加删除线的文字左右分别用两个~~号包起来</p><br/><p>示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**这是加粗的文字**</span></span><br><span class="line"><span class="emphasis">*这是倾斜的文字*</span>`</span><br><span class="line"><span class="strong">**<span class="emphasis">*这是斜体加粗的文字*</span>**</span></span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><strong>这是加粗的文字</strong></p><p><em>这是倾斜的文字</em>&#96;</p><p><em><strong>这是斜体加粗的文字</strong></em></p><p><del>这是加删除线的文字</del></p><h1 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h1><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;</p><p>n个…</p><p>貌似可以一直加下去，但没神马卵用</p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">这是引用的内容</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;这是引用的内容</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>这是引用的内容</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h1 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h1><p>三个或者三个以上的 - 或者 * 都可以。</p><p>示例：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">---</span></span><br><span class="line"><span class="section">----</span></span><br><span class="line"><span class="bullet">***</span></span><br><span class="line"><span class="bullet"></span><span class="strong">*****</span></span><br></pre></td></tr></table></figure><h2 id="效果如下："><a href="#效果如下：" class="headerlink" title="效果如下："></a>效果如下：</h2><hr><hr><hr><p>可以看到，显示效果是一样的。</p><h1 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h1><p><strong>语法：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址 <span class="string">&#x27;&#x27;</span>图片titl<span class="string">e&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="selector-attr">[blockchain]</span>(./../img/<span class="number">6860761</span>-fd2f51090a890873<span class="selector-class">.webp</span> <span class="string">&quot;区块链&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><p><img src="/./../img/6860761-fd2f51090a890873.webp" alt="blockchain" title="区块链"></p><p><strong>上传本地图片直接点击导航栏的图片标志，选择图片即可</strong></p><br/><h1 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h1><p><strong>语法：</strong></p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接<span class="built_in">title</span>&quot;)</span><br><span class="line"><span class="built_in">title</span>可加可不加</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[简书]</span>(<span class="attribute">http</span>:<span class="comment">//jianshu.com)</span></span><br><span class="line">[百度](<span class="attribute">http</span>:<span class="comment">//baidu.com)</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><a href="http://jianshu.com/">简书</a><br><a href="http://baidu.com/">百度</a></p><p>注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a <span class="attribute">href</span>=<span class="string">&quot;超链接地址&quot;</span> <span class="attribute">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;超链接名&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">&lt;a <span class="attribute">href</span>=<span class="string">&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot;</span> <span class="attribute">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;简书&lt;/a&gt;</span><br></pre></td></tr></table></figure><h1 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h1><p><strong>无序列表</strong></p><p>语法：</p><p>无序列表用 - + * 任何一种都可以</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 列表内容</span><br><span class="line"><span class="bullet">+</span> 列表内容</span><br><span class="line"><span class="bullet">*</span> 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + <span class="emphasis">* 跟内容之间都要有一个空格</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><p><strong>有序列表</strong></p><p>语法：</p><p>数字加点</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 列表内容</span><br><span class="line"><span class="bullet">2.</span> 列表内容</span><br><span class="line"><span class="bullet">3.</span> 列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure><p>效果如下：</p><ol><li>列表内容</li><li>列表内容</li><li>列表内容</li></ol><p><strong>列表嵌套</strong></p><p><strong>上一级和下一级之间敲三个空格即可</strong></p><ul><li><p>一级无序列表内容</p><ul><li>二级无序列表内容</li><li>二级无序列表内容</li><li>二级无序列表内容</li></ul></li><li><p>一级无序列表内容</p><ol><li>二级有序列表内容</li><li>二级有序列表内容</li><li>二级有序列表内容</li></ol></li></ul><ol><li><p>一级有序列表内容</p><ul><li>二级无序列表内容</li><li>二级无序列表内容</li><li>二级无序列表内容</li></ul></li><li><p>一级有序列表内容</p><ul><li>二级有序列表内容</li><li>二级有序列表内容</li><li>二级有序列表内容</li></ul></li></ol><br/><hr><h1 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h1><p>语法：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表头|<span class="string">表头</span>|<span class="string">表头</span></span><br><span class="line"><span class="string">---</span>|<span class="string">:--:</span>|<span class="string">---:</span></span><br><span class="line"><span class="string">内容</span>|<span class="string">内容</span>|<span class="string">内容</span></span><br><span class="line"><span class="string">内容</span>|<span class="string">内容</span>|<span class="string">内容</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第二行分割表头和内容。</span></span><br><span class="line"><span class="string">- 有一个就行，为了对齐，多加了几个</span></span><br><span class="line"><span class="string">文字默认居左</span></span><br><span class="line"><span class="string">-两边加：表示文字居中</span></span><br><span class="line"><span class="string">-右边加：表示文字居右</span></span><br><span class="line"><span class="string">注：原生的语法两边都要用 </span>|<span class="string"> 包起来。此处省略</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">姓名|<span class="string">技能</span>|<span class="string">排行</span></span><br><span class="line"><span class="string">--</span>|<span class="string">:--:</span>|<span class="string">--:</span></span><br><span class="line"><span class="string">刘备</span>|<span class="string">哭</span>|<span class="string">大哥</span></span><br><span class="line"><span class="string">关羽</span>|<span class="string">打</span>|<span class="string">二哥</span></span><br><span class="line"><span class="string">张飞</span>|<span class="string">骂</span>|<span class="string">三弟</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><table><thead><tr><th>姓名</th><th align="center">技能</th><th align="right">排行</th></tr></thead><tbody><tr><td>刘备</td><td align="center">哭</td><td align="right">大哥</td></tr><tr><td>关羽</td><td align="center">打</td><td align="right">二哥</td></tr><tr><td>张飞</td><td align="center">骂</td><td align="right">三弟</td></tr></tbody></table><br/><h1 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h1><p>语法：</p><p>单行代码：代码之间分别用一个反引号包起来</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`代码内容`</span></span><br></pre></td></tr></table></figure><p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(```)</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure><blockquote><p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中<br>去掉两边小括号即可。</p></blockquote><p>示例：</p><p>单行代码</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">create</span> <span class="keyword">database</span> hero;`</span><br></pre></td></tr></table></figure><p>代码块</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(```)</span><br><span class="line">    function <span class="function"><span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">         echo <span class="string">&quot;这是一句非常牛逼的代码&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>单行代码</p><p><code>create database hero;</code></p><p>代码块</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function <span class="function"><span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">  echo <span class="string">&quot;这是一句非常牛逼的代码&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h1 id="十、数字处理："><a href="#十、数字处理：" class="headerlink" title="十、数字处理："></a>十、数字处理：</h1><p><strong>上标和下标：</strong></p><ol><li>Markdown语法</li></ol><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>上标｜$x^2$: x^2^</td><td></td></tr><tr><td>下标｜$x_2$: x<del>2</del></td><td></td></tr></tbody></table><ol start="2"><li>使用LaTex</li></ol><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>上标｜$x^2$ : <code>$x^2$</code></td><td></td><td></td></tr><tr><td>下标｜$x_2$ : <code>$x_2x$</code></td><td></td><td></td></tr></tbody></table><ol start="3"><li>html 语法：</li></ol><p><strong>代码：</strong></p><p><code>C&lt;sub&gt;n-1&lt;/sub&gt;&lt;sup style=&quot;margin-left:-20px&quot;&gt;m+n-2&lt;/sup&gt;</code>  </p><p><strong>效果：</strong></p><p>C<sub>n-1</sub><sup style="margin-left:-20px">m+n-2</sup></p><p>单个<code>$</code>之间则可以嵌入文本当中，套两层$可实现公式居中。<br>如果要复合标，可使用 <code>&#123;&#125;</code>，如 $x^{C_2}$ : <code>$x^&#123;C_2&#125;$</code> </p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
